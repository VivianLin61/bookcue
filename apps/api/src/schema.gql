# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AuthResponse {
  accessToken: String!
  expiresIn: Float!
  refreshToken: String!
  user: User!
}

type Book {
  _count: BookCount!
  author: String
  categories: String
  coverImage: String
  description: String
  id: ID!
  pageNum: Int
  pubDate: String
  publisher: String
  title: String!
  userBook: [UserBook!]
}

type BookAvgAggregate {
  pageNum: Float
}

type BookCount {
  userBook: Int!
}

type BookCountAggregate {
  _all: Int!
  author: Int!
  categories: Int!
  coverImage: Int!
  description: Int!
  id: Int!
  pageNum: Int!
  pubDate: Int!
  publisher: Int!
  title: Int!
}

input BookCreateInput {
  author: String
  categories: String
  coverImage: String
  description: String
  id: String!
  pageNum: Int
  pubDate: String
  publisher: String
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
}

input BookCreateNestedOneWithoutUserBookInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
}

input BookCreateOrConnectWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutUserBookInput {
  author: String
  categories: String
  coverImage: String
  description: String
  id: String!
  pageNum: Int
  pubDate: String
  publisher: String
  title: String!
}

type BookMaxAggregate {
  author: String
  categories: String
  coverImage: String
  description: String
  id: String
  pageNum: Int
  pubDate: String
  publisher: String
  title: String
}

type BookMinAggregate {
  author: String
  categories: String
  coverImage: String
  description: String
  id: String
  pageNum: Int
  pubDate: String
  publisher: String
  title: String
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

type BookSumAggregate {
  pageNum: Int
}

input BookUpdateOneWithoutUserBookNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
  delete: BookWhereInput
  disconnect: BookWhereInput
  update: BookUpdateToOneWithWhereWithoutUserBookInput
  upsert: BookUpsertWithoutUserBookInput
}

input BookUpdateToOneWithWhereWithoutUserBookInput {
  data: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookUpdateWithoutUserBookInput {
  author: String
  categories: String
  coverImage: String
  description: String
  id: String
  pageNum: Int
  pubDate: String
  publisher: String
  title: String
}

input BookUpsertWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  update: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  author: StringFilter
  categories: StringFilter
  coverImage: StringFilter
  description: StringFilter
  id: StringFilter
  pageNum: IntFilter
  pubDate: StringFilter
  publisher: StringFilter
  title: StringFilter
  userBook: UserBookListRelationFilter
}

input BookWhereUniqueInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  author: StringFilter
  categories: StringFilter
  coverImage: StringFilter
  description: StringFilter
  id: String
  pageNum: IntFilter
  pubDate: StringFilter
  publisher: StringFilter
  title: StringFilter
  userBook: UserBookListRelationFilter
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: DateTimeFilter
  notIn: [Timestamp!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: IntFilter
  notIn: [Int!]
}

type JournalEntry {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp!
  id: ID!
  pagesRead: Int!
  readingNotes: String
  user: User
  userBook: UserBook
  userBookId: String
  userId: String
}

type JournalEntryAvgAggregate {
  currentPage: Float
  currentPercent: Float
  pagesRead: Float
}

type JournalEntryCountAggregate {
  _all: Int!
  currentPage: Int!
  currentPercent: Int!
  dateRead: Int!
  id: Int!
  pagesRead: Int!
  readingNotes: Int!
  userBookId: Int!
  userId: Int!
}

input JournalEntryCreateInput {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  user: UserCreateNestedOneWithoutJournalEntryInput
  userBook: UserBookCreateNestedOneWithoutJournalEntryInput
}

input JournalEntryCreateManyUserBookInput {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userId: String
}

input JournalEntryCreateManyUserBookInputEnvelope {
  data: [JournalEntryCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input JournalEntryCreateManyUserInput {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userBookId: String
}

input JournalEntryCreateManyUserInputEnvelope {
  data: [JournalEntryCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input JournalEntryCreateNestedManyWithoutUserBookInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserBookInput!]
  create: [JournalEntryCreateWithoutUserBookInput!]
  createMany: JournalEntryCreateManyUserBookInputEnvelope
}

input JournalEntryCreateNestedManyWithoutUserInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserInput!]
  create: [JournalEntryCreateWithoutUserInput!]
  createMany: JournalEntryCreateManyUserInputEnvelope
}

input JournalEntryCreateOrConnectWithoutUserBookInput {
  create: JournalEntryCreateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryCreateOrConnectWithoutUserInput {
  create: JournalEntryCreateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryCreateWithoutUserBookInput {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  user: UserCreateNestedOneWithoutJournalEntryInput
}

input JournalEntryCreateWithoutUserInput {
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userBook: UserBookCreateNestedOneWithoutJournalEntryInput
}

input JournalEntryListRelationFilter {
  every: JournalEntryWhereInput
  none: JournalEntryWhereInput
  some: JournalEntryWhereInput
}

type JournalEntryMaxAggregate {
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBookId: String
  userId: String
}

type JournalEntryMinAggregate {
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBookId: String
  userId: String
}

input JournalEntryScalarWhereInput {
  AND: [JournalEntryScalarWhereInput!]
  NOT: [JournalEntryScalarWhereInput!]
  OR: [JournalEntryScalarWhereInput!]
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: StringFilter
  pagesRead: IntFilter
  readingNotes: StringFilter
  userBookId: StringFilter
  userId: StringFilter
}

type JournalEntrySumAggregate {
  currentPage: Int
  currentPercent: Int
  pagesRead: Int
}

input JournalEntryUpdateManyMutationInput {
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
}

input JournalEntryUpdateManyWithWhereWithoutUserBookInput {
  data: JournalEntryUpdateManyMutationInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateManyWithWhereWithoutUserInput {
  data: JournalEntryUpdateManyMutationInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateManyWithoutUserBookNestedInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserBookInput!]
  create: [JournalEntryCreateWithoutUserBookInput!]
  createMany: JournalEntryCreateManyUserBookInputEnvelope
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [JournalEntryUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutUserBookInput!]
}

input JournalEntryUpdateManyWithoutUserNestedInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserInput!]
  create: [JournalEntryCreateWithoutUserInput!]
  createMany: JournalEntryCreateManyUserInputEnvelope
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [JournalEntryUpdateManyWithWhereWithoutUserInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutUserInput!]
}

input JournalEntryUpdateWithWhereUniqueWithoutUserBookInput {
  data: JournalEntryUpdateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpdateWithWhereUniqueWithoutUserInput {
  data: JournalEntryUpdateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpdateWithoutUserBookInput {
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  user: UserUpdateOneWithoutJournalEntryNestedInput
}

input JournalEntryUpdateWithoutUserInput {
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBook: UserBookUpdateOneWithoutJournalEntryNestedInput
}

input JournalEntryUpsertWithWhereUniqueWithoutUserBookInput {
  create: JournalEntryCreateWithoutUserBookInput!
  update: JournalEntryUpdateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpsertWithWhereUniqueWithoutUserInput {
  create: JournalEntryCreateWithoutUserInput!
  update: JournalEntryUpdateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryWhereInput {
  AND: [JournalEntryWhereInput!]
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: StringFilter
  pagesRead: IntFilter
  readingNotes: StringFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

input JournalEntryWhereUniqueInput {
  AND: [JournalEntryWhereInput!]
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: String
  pagesRead: IntFilter
  readingNotes: StringFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

input LogInInput {
  email: String!
  password: String!
}

type Mutation {
  createBook(data: BookCreateInput!): Book!
  createJournalEntry(book: BookWhereUniqueInput!, data: JournalEntryCreateInput!): JournalEntry!
  createShelf(data: ShelfCreateInput!): Shelf!
  createUser(userCreateInput: UserCreateInput!): User!
  deleteShelf(where: ShelfWhereUniqueInput!): Shelf
  logout(id: String!): Boolean!
  refreshAuth: RefreshResponse!
  removeUserBook(where: BookWhereUniqueInput!): UserBook!
  signin(logInInput: LogInInput!): AuthResponse!
  signup(registerInput: RegisterInput!): User!
  updateShelf(data: ShelfUpdateInput!, where: ShelfWhereUniqueInput!): Shelf
  updateUserBook(data: UserBookUpdateInput!, where: BookWhereUniqueInput!): UserBook!
}

type Query {
  countJournalEntries(book: BookWhereUniqueInput): Int!
  countUserBooks(where: UserBookWhereInput): Int!
  getMostRecentJournalEntry(book: BookWhereUniqueInput): JournalEntry
  journalEntries(book: BookWhereUniqueInput, limit: Int! = 20, offset: Int! = 0): [JournalEntry!]!
  me: User!
  shelves: [Shelf!]
  userBook(where: BookWhereUniqueInput!): UserBook
  userBooks(limit: Int! = 20, offset: Int! = 0, where: UserBookWhereInput): [UserBook!]
}

enum QueryMode {
  default
  insensitive
}

type RefreshResponse {
  accessToken: String!
  expiresIn: Float!
  refreshToken: String!
}

input RegisterInput {
  email: String!
  password: String!
  username: String!
}

type Shelf {
  _count: ShelfCount!
  dateTime: String
  id: ID!
  name: String!
  user: User
  userBooks: [UserBookShelves!]
  userId: String
}

type ShelfCount {
  userBooks: Int!
}

type ShelfCountAggregate {
  _all: Int!
  dateTime: Int!
  id: Int!
  name: Int!
  userId: Int!
}

input ShelfCreateInput {
  dateTime: String
  id: String
  name: String!
  user: UserCreateNestedOneWithoutShelvesInput
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfCreateManyUserInput {
  dateTime: String
  id: String
  name: String!
}

input ShelfCreateManyUserInputEnvelope {
  data: [ShelfCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ShelfCreateNestedManyWithoutUserInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
}

input ShelfCreateNestedOneWithoutUserBooksInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
}

input ShelfCreateOrConnectWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateOrConnectWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String!
  user: UserCreateNestedOneWithoutShelvesInput
}

input ShelfCreateWithoutUserInput {
  dateTime: String
  id: String
  name: String!
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfIdentifierCompoundUniqueInput {
  name: String!
  userId: String!
}

input ShelfListRelationFilter {
  every: ShelfWhereInput
  none: ShelfWhereInput
  some: ShelfWhereInput
}

type ShelfMaxAggregate {
  dateTime: String
  id: String
  name: String
  userId: String
}

type ShelfMinAggregate {
  dateTime: String
  id: String
  name: String
  userId: String
}

input ShelfRelationFilter {
  is: ShelfWhereInput
  isNot: ShelfWhereInput
}

input ShelfScalarWhereInput {
  AND: [ShelfScalarWhereInput!]
  NOT: [ShelfScalarWhereInput!]
  OR: [ShelfScalarWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  userId: StringFilter
}

input ShelfUpdateInput {
  dateTime: String
  id: String
  name: String
  user: UserUpdateOneWithoutShelvesNestedInput
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpdateManyMutationInput {
  dateTime: String
  id: String
  name: String
}

input ShelfUpdateManyWithWhereWithoutUserInput {
  data: ShelfUpdateManyMutationInput!
  where: ShelfScalarWhereInput!
}

input ShelfUpdateManyWithoutUserNestedInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
  delete: [ShelfWhereUniqueInput!]
  deleteMany: [ShelfScalarWhereInput!]
  disconnect: [ShelfWhereUniqueInput!]
  set: [ShelfWhereUniqueInput!]
  update: [ShelfUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ShelfUpdateManyWithWhereWithoutUserInput!]
  upsert: [ShelfUpsertWithWhereUniqueWithoutUserInput!]
}

input ShelfUpdateOneRequiredWithoutUserBooksNestedInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
  update: ShelfUpdateToOneWithWhereWithoutUserBooksInput
  upsert: ShelfUpsertWithoutUserBooksInput
}

input ShelfUpdateToOneWithWhereWithoutUserBooksInput {
  data: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfUpdateWithWhereUniqueWithoutUserInput {
  data: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpdateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String
  user: UserUpdateOneWithoutShelvesNestedInput
}

input ShelfUpdateWithoutUserInput {
  dateTime: String
  id: String
  name: String
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpsertWithWhereUniqueWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  update: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpsertWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  update: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfWhereInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  user: UserRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

input ShelfWhereUniqueInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: String
  identifier: ShelfIdentifierCompoundUniqueInput
  name: StringFilter
  user: UserRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: StringFilter
  notIn: [String!]
  startsWith: String
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  JournalEntry: [JournalEntry!]
  _count: UserCount!
  createdAt: Timestamp!
  email: String!
  id: ID!
  shelves: [Shelf!]
  updatedAt: Timestamp!
  userBooks: [UserBook!]
  username: String
}

type UserBook {
  _count: UserBookCount!
  book: Book
  bookId: String!
  dataAdded: Timestamp!
  id: ID!
  journalEntry: [JournalEntry!]
  rating: Int
  shelves: [UserBookShelves!]
  status: String!
  user: User
  userId: String!
}

type UserBookAvgAggregate {
  rating: Float
}

type UserBookCount {
  journalEntry: Int!
  shelves: Int!
}

type UserBookCountAggregate {
  _all: Int!
  bookId: Int!
  dataAdded: Int!
  id: Int!
  rating: Int!
  status: Int!
  userId: Int!
}

input UserBookCreateManyBookInput {
  dataAdded: Timestamp
  id: String
  rating: Int
  status: String!
  userId: String!
}

input UserBookCreateManyBookInputEnvelope {
  data: [UserBookCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input UserBookCreateManyUserInput {
  bookId: String!
  dataAdded: Timestamp
  id: String
  rating: Int
  status: String!
}

input UserBookCreateManyUserInputEnvelope {
  data: [UserBookCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserBookCreateNestedManyWithoutBookInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutBookInput!]
  create: [UserBookCreateWithoutBookInput!]
  createMany: UserBookCreateManyBookInputEnvelope
}

input UserBookCreateNestedManyWithoutUserInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
}

input UserBookCreateNestedOneWithoutJournalEntryInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutJournalEntryInput
  create: UserBookCreateWithoutJournalEntryInput
}

input UserBookCreateNestedOneWithoutShelvesInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
}

input UserBookCreateOrConnectWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutJournalEntryInput {
  create: UserBookCreateWithoutJournalEntryInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateWithoutBookInput {
  dataAdded: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  rating: Int
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutJournalEntryInput {
  book: BookCreateNestedOneWithoutUserBookInput
  dataAdded: Timestamp
  id: String
  rating: Int
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutShelvesInput {
  book: BookCreateNestedOneWithoutUserBookInput
  dataAdded: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  rating: Int
  status: String!
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutUserInput {
  book: BookCreateNestedOneWithoutUserBookInput
  dataAdded: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  rating: Int
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
}

input UserBookIdentifierCompoundUniqueInput {
  bookId: String!
  userId: String!
}

input UserBookListRelationFilter {
  every: UserBookWhereInput
  none: UserBookWhereInput
  some: UserBookWhereInput
}

type UserBookMaxAggregate {
  bookId: String
  dataAdded: Timestamp
  id: String
  rating: Int
  status: String
  userId: String
}

type UserBookMinAggregate {
  bookId: String
  dataAdded: Timestamp
  id: String
  rating: Int
  status: String
  userId: String
}

input UserBookRelationFilter {
  is: UserBookWhereInput
  isNot: UserBookWhereInput
}

input UserBookScalarWhereInput {
  AND: [UserBookScalarWhereInput!]
  NOT: [UserBookScalarWhereInput!]
  OR: [UserBookScalarWhereInput!]
  bookId: StringFilter
  dataAdded: DateTimeFilter
  id: StringFilter
  rating: IntFilter
  status: StringFilter
  userId: StringFilter
}

type UserBookShelves {
  shelf: Shelf!
  shelfId: String!
  userBook: UserBook!
  userBookId: String!
}

type UserBookShelvesCountAggregate {
  _all: Int!
  shelfId: Int!
  userBookId: Int!
}

input UserBookShelvesCreateManyShelfInput {
  userBookId: String!
}

input UserBookShelvesCreateManyShelfInputEnvelope {
  data: [UserBookShelvesCreateManyShelfInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateManyUserBookInput {
  shelfId: String!
}

input UserBookShelvesCreateManyUserBookInputEnvelope {
  data: [UserBookShelvesCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateNestedManyWithoutShelfInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
}

input UserBookShelvesCreateNestedManyWithoutUserBookInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
}

input UserBookShelvesCreateOrConnectWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateOrConnectWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateWithoutShelfInput {
  userBook: UserBookCreateNestedOneWithoutShelvesInput!
}

input UserBookShelvesCreateWithoutUserBookInput {
  shelf: ShelfCreateNestedOneWithoutUserBooksInput!
}

input UserBookShelvesListRelationFilter {
  every: UserBookShelvesWhereInput
  none: UserBookShelvesWhereInput
  some: UserBookShelvesWhereInput
}

type UserBookShelvesMaxAggregate {
  shelfId: String
  userBookId: String
}

type UserBookShelvesMinAggregate {
  shelfId: String
  userBookId: String
}

input UserBookShelvesScalarWhereInput {
  AND: [UserBookShelvesScalarWhereInput!]
  NOT: [UserBookShelvesScalarWhereInput!]
  OR: [UserBookShelvesScalarWhereInput!]
  shelfId: StringFilter
  userBookId: StringFilter
}

input UserBookShelvesUncheckedUpdateManyWithoutShelfInput {
  userBookId: String
}

input UserBookShelvesUncheckedUpdateManyWithoutUserBookInput {
  shelfId: String
}

input UserBookShelvesUpdateManyWithWhereWithoutShelfInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutShelfInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithWhereWithoutUserBookInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutUserBookInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithoutShelfNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutShelfInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput!]
}

input UserBookShelvesUpdateManyWithoutUserBookNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput!]
}

input UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput {
  data: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput {
  data: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithoutShelfInput {
  userBook: UserBookUpdateOneRequiredWithoutShelvesNestedInput
}

input UserBookShelvesUpdateWithoutUserBookInput {
  shelf: ShelfUpdateOneRequiredWithoutUserBooksNestedInput
}

input UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  update: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  update: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUserBookIdShelfIdCompoundUniqueInput {
  shelfId: String!
  userBookId: String!
}

input UserBookShelvesWhereInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfRelationFilter
  shelfId: StringFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
}

input UserBookShelvesWhereUniqueInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfRelationFilter
  shelfId: StringFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userBookId_shelfId: UserBookShelvesUserBookIdShelfIdCompoundUniqueInput
}

type UserBookSumAggregate {
  rating: Int
}

input UserBookUpdateInput {
  rating: Float
  shelves: [String!]
  status: String
}

input UserBookUpdateManyMutationInput {
  dataAdded: Timestamp
  id: String
  rating: Int
  status: String
}

input UserBookUpdateManyWithWhereWithoutUserInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithoutUserNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutUserInput!]
}

input UserBookUpdateOneRequiredWithoutShelvesNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
  update: UserBookUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserBookUpsertWithoutShelvesInput
}

input UserBookUpdateOneWithoutJournalEntryNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutJournalEntryInput
  create: UserBookCreateWithoutJournalEntryInput
  delete: UserBookWhereInput
  disconnect: UserBookWhereInput
  update: UserBookUpdateToOneWithWhereWithoutJournalEntryInput
  upsert: UserBookUpsertWithoutJournalEntryInput
}

input UserBookUpdateToOneWithWhereWithoutJournalEntryInput {
  data: UserBookUpdateWithoutJournalEntryInput!
  where: UserBookWhereInput
}

input UserBookUpdateToOneWithWhereWithoutShelvesInput {
  data: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookUpdateWithWhereUniqueWithoutUserInput {
  data: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithoutJournalEntryInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  dataAdded: Timestamp
  id: String
  rating: Int
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutShelvesInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  dataAdded: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  rating: Int
  status: String
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutUserInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  dataAdded: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  rating: Int
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
}

input UserBookUpsertWithWhereUniqueWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  update: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpsertWithoutJournalEntryInput {
  create: UserBookCreateWithoutJournalEntryInput!
  update: UserBookUpdateWithoutJournalEntryInput!
  where: UserBookWhereInput
}

input UserBookUpsertWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  update: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookWhereInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookRelationFilter
  bookId: StringFilter
  dataAdded: DateTimeFilter
  id: StringFilter
  journalEntry: JournalEntryListRelationFilter
  rating: IntFilter
  shelves: UserBookShelvesListRelationFilter
  status: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input UserBookWhereUniqueInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookRelationFilter
  bookId: StringFilter
  dataAdded: DateTimeFilter
  id: String
  identifier: UserBookIdentifierCompoundUniqueInput
  journalEntry: JournalEntryListRelationFilter
  rating: IntFilter
  shelves: UserBookShelvesListRelationFilter
  status: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

type UserCount {
  JournalEntry: Int!
  shelves: Int!
  userBooks: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateInput {
  JournalEntry: JournalEntryCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateNestedOneWithoutJournalEntryInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutJournalEntryInput
  create: UserCreateWithoutJournalEntryInput
}

input UserCreateNestedOneWithoutShelvesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
}

input UserCreateNestedOneWithoutUserBooksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
}

input UserCreateOrConnectWithoutJournalEntryInput {
  create: UserCreateWithoutJournalEntryInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutJournalEntryInput {
  createdAt: Timestamp
  email: String!
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutShelvesInput {
  JournalEntry: JournalEntryCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutUserBooksInput {
  JournalEntry: JournalEntryCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  username: String
}

type UserMaxAggregate {
  createdAt: Timestamp
  email: String
  id: String
  updatedAt: Timestamp
  username: String
}

type UserMinAggregate {
  createdAt: Timestamp
  email: String
  id: String
  updatedAt: Timestamp
  username: String
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserUpdateOneWithoutJournalEntryNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutJournalEntryInput
  create: UserCreateWithoutJournalEntryInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutJournalEntryInput
  upsert: UserUpsertWithoutJournalEntryInput
}

input UserUpdateOneWithoutShelvesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserUpsertWithoutShelvesInput
}

input UserUpdateOneWithoutUserBooksNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutUserBooksInput
  upsert: UserUpsertWithoutUserBooksInput
}

input UserUpdateToOneWithWhereWithoutJournalEntryInput {
  data: UserUpdateWithoutJournalEntryInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutShelvesInput {
  data: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutUserBooksInput {
  data: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserUpdateWithoutJournalEntryInput {
  createdAt: Timestamp
  email: String
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutShelvesInput {
  JournalEntry: JournalEntryUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutUserBooksInput {
  JournalEntry: JournalEntryUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  username: String
}

input UserUpsertWithoutJournalEntryInput {
  create: UserCreateWithoutJournalEntryInput!
  update: UserUpdateWithoutJournalEntryInput!
  where: UserWhereInput
}

input UserUpsertWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  update: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpsertWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  update: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  JournalEntry: JournalEntryListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: StringFilter
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  JournalEntry: JournalEntryListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: String
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: String
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: String
}