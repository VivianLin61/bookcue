# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum ACTION {
  COMMENT
  LIKE
  LOG
  RATE
  REVIEW
  SHELVE
  STATUS_UPDATE
}

type Account {
  access_token: String
  expires_at: Int
  id: ID!
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: User!
  userId: String!
}

type AccountAvgAggregate {
  expires_at: Float
}

type AccountCountAggregate {
  _all: Int!
  access_token: Int!
  expires_at: Int!
  id: Int!
  id_token: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  scope: Int!
  session_state: Int!
  token_type: Int!
  type: Int!
  userId: Int!
}

input AccountCreateManyUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

type AccountMaxAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

type AccountMinAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringFilter
  expires_at: IntFilter
  id: StringFilter
  id_token: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringFilter
  scope: StringFilter
  session_state: StringFilter
  token_type: StringFilter
  type: StringFilter
  userId: StringFilter
}

type AccountSumAggregate {
  expires_at: Int
}

input AccountUpdateManyMutationInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserNestedInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringFilter
  expires_at: IntFilter
  id: StringFilter
  id_token: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringFilter
  scope: StringFilter
  session_state: StringFilter
  token_type: StringFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringFilter
  expires_at: IntFilter
  id: String
  id_token: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
  refresh_token: StringFilter
  scope: StringFilter
  session_state: StringFilter
  token_type: StringFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

type ActivitiesResponse {
  activities: [AuditLog!]
  hasMore: Boolean!
  totalActivities: Float!
}

type AuditLog {
  action: ACTION!
  actionContent: String
  book: Book
  bookId: Int!
  createdAt: Timestamp!
  id: ID!
  updatedAt: Timestamp!
  user: User
  userId: String!
}

type AuditLogAvgAggregate {
  bookId: Float
}

type AuditLogCountAggregate {
  _all: Int!
  action: Int!
  actionContent: Int!
  bookId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input AuditLogCreateManyBookInput {
  action: ACTION!
  actionContent: String
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
  userId: String!
}

input AuditLogCreateManyBookInputEnvelope {
  data: [AuditLogCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input AuditLogCreateManyUserInput {
  action: ACTION!
  actionContent: String
  bookId: Int!
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input AuditLogCreateManyUserInputEnvelope {
  data: [AuditLogCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AuditLogCreateNestedManyWithoutBookInput {
  connect: [AuditLogWhereUniqueInput!]
  connectOrCreate: [AuditLogCreateOrConnectWithoutBookInput!]
  create: [AuditLogCreateWithoutBookInput!]
  createMany: AuditLogCreateManyBookInputEnvelope
}

input AuditLogCreateNestedManyWithoutUserInput {
  connect: [AuditLogWhereUniqueInput!]
  connectOrCreate: [AuditLogCreateOrConnectWithoutUserInput!]
  create: [AuditLogCreateWithoutUserInput!]
  createMany: AuditLogCreateManyUserInputEnvelope
}

input AuditLogCreateOrConnectWithoutBookInput {
  create: AuditLogCreateWithoutBookInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogCreateOrConnectWithoutUserInput {
  create: AuditLogCreateWithoutUserInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogCreateWithoutBookInput {
  action: ACTION!
  actionContent: String
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutAuditLogsInput
}

input AuditLogCreateWithoutUserInput {
  action: ACTION!
  actionContent: String
  book: BookCreateNestedOneWithoutLogsInput
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input AuditLogListRelationFilter {
  every: AuditLogWhereInput
  none: AuditLogWhereInput
  some: AuditLogWhereInput
}

type AuditLogMaxAggregate {
  action: ACTION
  actionContent: String
  bookId: Int
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
  userId: String
}

type AuditLogMinAggregate {
  action: ACTION
  actionContent: String
  bookId: Int
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
  userId: String
}

input AuditLogOrderByRelationAggregateInput {
  _count: SortOrder
}

input AuditLogOrderByWithRelationInput {
  action: SortOrder
  actionContent: SortOrderInput
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input AuditLogScalarWhereInput {
  AND: [AuditLogScalarWhereInput!]
  NOT: [AuditLogScalarWhereInput!]
  OR: [AuditLogScalarWhereInput!]
  action: EnumACTIONFilter
  actionContent: StringFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

type AuditLogSumAggregate {
  bookId: Int
}

input AuditLogUpdateManyMutationInput {
  action: ACTION
  actionContent: String
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input AuditLogUpdateManyWithWhereWithoutBookInput {
  data: AuditLogUpdateManyMutationInput!
  where: AuditLogScalarWhereInput!
}

input AuditLogUpdateManyWithWhereWithoutUserInput {
  data: AuditLogUpdateManyMutationInput!
  where: AuditLogScalarWhereInput!
}

input AuditLogUpdateManyWithoutBookNestedInput {
  connect: [AuditLogWhereUniqueInput!]
  connectOrCreate: [AuditLogCreateOrConnectWithoutBookInput!]
  create: [AuditLogCreateWithoutBookInput!]
  createMany: AuditLogCreateManyBookInputEnvelope
  delete: [AuditLogWhereUniqueInput!]
  deleteMany: [AuditLogScalarWhereInput!]
  disconnect: [AuditLogWhereUniqueInput!]
  set: [AuditLogWhereUniqueInput!]
  update: [AuditLogUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [AuditLogUpdateManyWithWhereWithoutBookInput!]
  upsert: [AuditLogUpsertWithWhereUniqueWithoutBookInput!]
}

input AuditLogUpdateManyWithoutUserNestedInput {
  connect: [AuditLogWhereUniqueInput!]
  connectOrCreate: [AuditLogCreateOrConnectWithoutUserInput!]
  create: [AuditLogCreateWithoutUserInput!]
  createMany: AuditLogCreateManyUserInputEnvelope
  delete: [AuditLogWhereUniqueInput!]
  deleteMany: [AuditLogScalarWhereInput!]
  disconnect: [AuditLogWhereUniqueInput!]
  set: [AuditLogWhereUniqueInput!]
  update: [AuditLogUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AuditLogUpdateManyWithWhereWithoutUserInput!]
  upsert: [AuditLogUpsertWithWhereUniqueWithoutUserInput!]
}

input AuditLogUpdateWithWhereUniqueWithoutBookInput {
  data: AuditLogUpdateWithoutBookInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogUpdateWithWhereUniqueWithoutUserInput {
  data: AuditLogUpdateWithoutUserInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogUpdateWithoutBookInput {
  action: ACTION
  actionContent: String
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
  user: UserUpdateOneWithoutAuditLogsNestedInput
}

input AuditLogUpdateWithoutUserInput {
  action: ACTION
  actionContent: String
  book: BookUpdateOneWithoutLogsNestedInput
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input AuditLogUpsertWithWhereUniqueWithoutBookInput {
  create: AuditLogCreateWithoutBookInput!
  update: AuditLogUpdateWithoutBookInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogUpsertWithWhereUniqueWithoutUserInput {
  create: AuditLogCreateWithoutUserInput!
  update: AuditLogUpdateWithoutUserInput!
  where: AuditLogWhereUniqueInput!
}

input AuditLogWhereInput {
  AND: [AuditLogWhereInput!]
  NOT: [AuditLogWhereInput!]
  OR: [AuditLogWhereInput!]
  action: EnumACTIONFilter
  actionContent: StringFilter
  book: BookRelationFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AuditLogWhereUniqueInput {
  AND: [AuditLogWhereInput!]
  NOT: [AuditLogWhereInput!]
  OR: [AuditLogWhereInput!]
  action: EnumACTIONFilter
  actionContent: StringFilter
  book: BookRelationFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: String
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

type AuthResponse {
  accessToken: String
  expiresIn: Float
  isNewUser: Boolean
  refreshToken: String
  user: User!
  verificationToken: String
}

type Author {
  _count: AuthorCount!
  bio: String
  birthDate: Timestamp
  books: [Book!]
  deathDate: Timestamp
  id: ID!
  name: String!
  photo: String
  wikipedia: String
  works: [Work!]
}

type AuthorCount {
  books: Int!
  works: Int!
}

type AuthorCountAggregate {
  _all: Int!
  bio: Int!
  birthDate: Int!
  deathDate: Int!
  id: Int!
  name: Int!
  photo: Int!
  wikipedia: Int!
}

input AuthorCreateInput {
  bio: String
  birthDate: Timestamp
  books: BookCreateNestedManyWithoutAuthorsInput
  deathDate: Timestamp
  id: String
  name: String!
  photo: String
  wikipedia: String
  works: WorkCreateNestedManyWithoutAuthorsInput
}

input AuthorCreateNestedManyWithoutBooksInput {
  connect: [AuthorWhereUniqueInput!]
  connectOrCreate: [AuthorCreateOrConnectWithoutBooksInput!]
  create: [AuthorCreateWithoutBooksInput!]
}

input AuthorCreateNestedManyWithoutWorksInput {
  connect: [AuthorWhereUniqueInput!]
  connectOrCreate: [AuthorCreateOrConnectWithoutWorksInput!]
  create: [AuthorCreateWithoutWorksInput!]
}

input AuthorCreateOrConnectWithoutBooksInput {
  create: AuthorCreateWithoutBooksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateOrConnectWithoutWorksInput {
  create: AuthorCreateWithoutWorksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateWithoutBooksInput {
  bio: String
  birthDate: Timestamp
  deathDate: Timestamp
  id: String
  name: String!
  photo: String
  wikipedia: String
  works: WorkCreateNestedManyWithoutAuthorsInput
}

input AuthorCreateWithoutWorksInput {
  bio: String
  birthDate: Timestamp
  books: BookCreateNestedManyWithoutAuthorsInput
  deathDate: Timestamp
  id: String
  name: String!
  photo: String
  wikipedia: String
}

input AuthorListRelationFilter {
  every: AuthorWhereInput
  none: AuthorWhereInput
  some: AuthorWhereInput
}

type AuthorMaxAggregate {
  bio: String
  birthDate: Timestamp
  deathDate: Timestamp
  id: String
  name: String
  photo: String
  wikipedia: String
}

type AuthorMinAggregate {
  bio: String
  birthDate: Timestamp
  deathDate: Timestamp
  id: String
  name: String
  photo: String
  wikipedia: String
}

input AuthorOrderByRelationAggregateInput {
  _count: SortOrder
}

input AuthorScalarWhereInput {
  AND: [AuthorScalarWhereInput!]
  NOT: [AuthorScalarWhereInput!]
  OR: [AuthorScalarWhereInput!]
  bio: StringFilter
  birthDate: DateTimeFilter
  deathDate: DateTimeFilter
  id: StringFilter
  name: StringFilter
  photo: StringFilter
  wikipedia: StringFilter
}

input AuthorUpdateManyMutationInput {
  bio: String
  birthDate: Timestamp
  deathDate: Timestamp
  id: String
  name: String
  photo: String
  wikipedia: String
}

input AuthorUpdateManyWithWhereWithoutBooksInput {
  data: AuthorUpdateManyMutationInput!
  where: AuthorScalarWhereInput!
}

input AuthorUpdateManyWithWhereWithoutWorksInput {
  data: AuthorUpdateManyMutationInput!
  where: AuthorScalarWhereInput!
}

input AuthorUpdateManyWithoutBooksNestedInput {
  connect: [AuthorWhereUniqueInput!]
  connectOrCreate: [AuthorCreateOrConnectWithoutBooksInput!]
  create: [AuthorCreateWithoutBooksInput!]
  delete: [AuthorWhereUniqueInput!]
  deleteMany: [AuthorScalarWhereInput!]
  disconnect: [AuthorWhereUniqueInput!]
  set: [AuthorWhereUniqueInput!]
  update: [AuthorUpdateWithWhereUniqueWithoutBooksInput!]
  updateMany: [AuthorUpdateManyWithWhereWithoutBooksInput!]
  upsert: [AuthorUpsertWithWhereUniqueWithoutBooksInput!]
}

input AuthorUpdateManyWithoutWorksNestedInput {
  connect: [AuthorWhereUniqueInput!]
  connectOrCreate: [AuthorCreateOrConnectWithoutWorksInput!]
  create: [AuthorCreateWithoutWorksInput!]
  delete: [AuthorWhereUniqueInput!]
  deleteMany: [AuthorScalarWhereInput!]
  disconnect: [AuthorWhereUniqueInput!]
  set: [AuthorWhereUniqueInput!]
  update: [AuthorUpdateWithWhereUniqueWithoutWorksInput!]
  updateMany: [AuthorUpdateManyWithWhereWithoutWorksInput!]
  upsert: [AuthorUpsertWithWhereUniqueWithoutWorksInput!]
}

input AuthorUpdateWithWhereUniqueWithoutBooksInput {
  data: AuthorUpdateWithoutBooksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorUpdateWithWhereUniqueWithoutWorksInput {
  data: AuthorUpdateWithoutWorksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorUpdateWithoutBooksInput {
  bio: String
  birthDate: Timestamp
  deathDate: Timestamp
  id: String
  name: String
  photo: String
  wikipedia: String
  works: WorkUpdateManyWithoutAuthorsNestedInput
}

input AuthorUpdateWithoutWorksInput {
  bio: String
  birthDate: Timestamp
  books: BookUpdateManyWithoutAuthorsNestedInput
  deathDate: Timestamp
  id: String
  name: String
  photo: String
  wikipedia: String
}

input AuthorUpsertWithWhereUniqueWithoutBooksInput {
  create: AuthorCreateWithoutBooksInput!
  update: AuthorUpdateWithoutBooksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorUpsertWithWhereUniqueWithoutWorksInput {
  create: AuthorCreateWithoutWorksInput!
  update: AuthorUpdateWithoutWorksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorWhereInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  bio: StringFilter
  birthDate: DateTimeFilter
  books: BookListRelationFilter
  deathDate: DateTimeFilter
  id: StringFilter
  name: StringFilter
  photo: StringFilter
  wikipedia: StringFilter
  works: WorkListRelationFilter
}

input AuthorWhereUniqueInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  bio: StringFilter
  birthDate: DateTimeFilter
  books: BookListRelationFilter
  deathDate: DateTimeFilter
  id: String
  name: StringFilter
  photo: StringFilter
  wikipedia: StringFilter
  works: WorkListRelationFilter
}

type Book {
  _count: BookCount!
  authors: [Author!]
  coverImage: String
  covers: [Cover!]
  description: String
  id: ID!
  identifier: Identifier
  language: String
  logs: [AuditLog!]
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: [Review!]
  title: String!
  userBook: [UserBook!]
  work: Work
  workId: String
}

type BookAvgAggregate {
  id: Float
  pageCount: Float
}

type BookCount {
  authors: Int!
  covers: Int!
  logs: Int!
  reviews: Int!
  userBook: Int!
}

type BookCountAggregate {
  _all: Int!
  coverImage: Int!
  description: Int!
  id: Int!
  language: Int!
  pageCount: Int!
  publishedDate: Int!
  publisher: Int!
  title: Int!
  workId: Int!
}

input BookCreateInput {
  authors: AuthorCreateNestedManyWithoutBooksInput
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  logs: AuditLogCreateNestedManyWithoutBookInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewCreateNestedManyWithoutBookInput
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
  work: WorkCreateNestedOneWithoutEditionsInput
}

input BookCreateManyWorkInput {
  coverImage: String
  description: String
  id: Int
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String!
}

input BookCreateManyWorkInputEnvelope {
  data: [BookCreateManyWorkInput!]!
  skipDuplicates: Boolean
}

input BookCreateNestedManyWithoutAuthorsInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutAuthorsInput!]
  create: [BookCreateWithoutAuthorsInput!]
}

input BookCreateNestedManyWithoutWorkInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutWorkInput!]
  create: [BookCreateWithoutWorkInput!]
  createMany: BookCreateManyWorkInputEnvelope
}

input BookCreateNestedOneWithoutLogsInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutLogsInput
  create: BookCreateWithoutLogsInput
}

input BookCreateNestedOneWithoutReviewsInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutReviewsInput
  create: BookCreateWithoutReviewsInput
}

input BookCreateNestedOneWithoutUserBookInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
}

input BookCreateOrConnectWithoutAuthorsInput {
  create: BookCreateWithoutAuthorsInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutLogsInput {
  create: BookCreateWithoutLogsInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutReviewsInput {
  create: BookCreateWithoutReviewsInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutWorkInput {
  create: BookCreateWithoutWorkInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutAuthorsInput {
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  logs: AuditLogCreateNestedManyWithoutBookInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewCreateNestedManyWithoutBookInput
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
  work: WorkCreateNestedOneWithoutEditionsInput
}

input BookCreateWithoutLogsInput {
  authors: AuthorCreateNestedManyWithoutBooksInput
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewCreateNestedManyWithoutBookInput
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
  work: WorkCreateNestedOneWithoutEditionsInput
}

input BookCreateWithoutReviewsInput {
  authors: AuthorCreateNestedManyWithoutBooksInput
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  logs: AuditLogCreateNestedManyWithoutBookInput
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
  work: WorkCreateNestedOneWithoutEditionsInput
}

input BookCreateWithoutUserBookInput {
  authors: AuthorCreateNestedManyWithoutBooksInput
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  logs: AuditLogCreateNestedManyWithoutBookInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewCreateNestedManyWithoutBookInput
  title: String!
  work: WorkCreateNestedOneWithoutEditionsInput
}

input BookCreateWithoutWorkInput {
  authors: AuthorCreateNestedManyWithoutBooksInput
  coverImage: String
  covers: CoverCreateNestedManyWithoutBookInput
  description: String
  identifier: IdentifierCreateNestedOneWithoutBookInput
  language: String
  logs: AuditLogCreateNestedManyWithoutBookInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewCreateNestedManyWithoutBookInput
  title: String!
  userBook: UserBookCreateNestedManyWithoutBookInput
}

input BookItemInput {
  id: Float!
  order: Float!
  status: String!
  title: String!
}

input BookListRelationFilter {
  every: BookWhereInput
  none: BookWhereInput
  some: BookWhereInput
}

type BookMaxAggregate {
  coverImage: String
  description: String
  id: Int
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String
  workId: String
}

type BookMinAggregate {
  coverImage: String
  description: String
  id: Int
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String
  workId: String
}

input BookOrderByRelationAggregateInput {
  _count: SortOrder
}

input BookOrderByWithRelationInput {
  authors: AuthorOrderByRelationAggregateInput
  coverImage: SortOrderInput
  covers: CoverOrderByRelationAggregateInput
  description: SortOrderInput
  id: SortOrder
  identifier: IdentifierOrderByWithRelationInput
  language: SortOrderInput
  logs: AuditLogOrderByRelationAggregateInput
  pageCount: SortOrderInput
  publishedDate: SortOrderInput
  publisher: SortOrderInput
  reviews: ReviewOrderByRelationAggregateInput
  title: SortOrder
  userBook: UserBookOrderByRelationAggregateInput
  work: WorkOrderByWithRelationInput
  workId: SortOrderInput
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

input BookScalarWhereInput {
  AND: [BookScalarWhereInput!]
  NOT: [BookScalarWhereInput!]
  OR: [BookScalarWhereInput!]
  coverImage: StringFilter
  description: StringFilter
  id: IntFilter
  language: StringFilter
  pageCount: IntFilter
  publishedDate: StringFilter
  publisher: StringFilter
  title: StringFilter
  workId: StringFilter
}

type BookSumAggregate {
  id: Int
  pageCount: Int
}

input BookUpdateManyMutationInput {
  coverImage: String
  description: String
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String
}

input BookUpdateManyWithWhereWithoutAuthorsInput {
  data: BookUpdateManyMutationInput!
  where: BookScalarWhereInput!
}

input BookUpdateManyWithWhereWithoutWorkInput {
  data: BookUpdateManyMutationInput!
  where: BookScalarWhereInput!
}

input BookUpdateManyWithoutAuthorsNestedInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutAuthorsInput!]
  create: [BookCreateWithoutAuthorsInput!]
  delete: [BookWhereUniqueInput!]
  deleteMany: [BookScalarWhereInput!]
  disconnect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  update: [BookUpdateWithWhereUniqueWithoutAuthorsInput!]
  updateMany: [BookUpdateManyWithWhereWithoutAuthorsInput!]
  upsert: [BookUpsertWithWhereUniqueWithoutAuthorsInput!]
}

input BookUpdateManyWithoutWorkNestedInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutWorkInput!]
  create: [BookCreateWithoutWorkInput!]
  createMany: BookCreateManyWorkInputEnvelope
  delete: [BookWhereUniqueInput!]
  deleteMany: [BookScalarWhereInput!]
  disconnect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  update: [BookUpdateWithWhereUniqueWithoutWorkInput!]
  updateMany: [BookUpdateManyWithWhereWithoutWorkInput!]
  upsert: [BookUpsertWithWhereUniqueWithoutWorkInput!]
}

input BookUpdateOneWithoutLogsNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutLogsInput
  create: BookCreateWithoutLogsInput
  delete: BookWhereInput
  disconnect: BookWhereInput
  update: BookUpdateToOneWithWhereWithoutLogsInput
  upsert: BookUpsertWithoutLogsInput
}

input BookUpdateOneWithoutReviewsNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutReviewsInput
  create: BookCreateWithoutReviewsInput
  delete: BookWhereInput
  disconnect: BookWhereInput
  update: BookUpdateToOneWithWhereWithoutReviewsInput
  upsert: BookUpsertWithoutReviewsInput
}

input BookUpdateOneWithoutUserBookNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
  delete: BookWhereInput
  disconnect: BookWhereInput
  update: BookUpdateToOneWithWhereWithoutUserBookInput
  upsert: BookUpsertWithoutUserBookInput
}

input BookUpdateToOneWithWhereWithoutLogsInput {
  data: BookUpdateWithoutLogsInput!
  where: BookWhereInput
}

input BookUpdateToOneWithWhereWithoutReviewsInput {
  data: BookUpdateWithoutReviewsInput!
  where: BookWhereInput
}

input BookUpdateToOneWithWhereWithoutUserBookInput {
  data: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookUpdateWithWhereUniqueWithoutAuthorsInput {
  data: BookUpdateWithoutAuthorsInput!
  where: BookWhereUniqueInput!
}

input BookUpdateWithWhereUniqueWithoutWorkInput {
  data: BookUpdateWithoutWorkInput!
  where: BookWhereUniqueInput!
}

input BookUpdateWithoutAuthorsInput {
  coverImage: String
  covers: CoverUpdateManyWithoutBookNestedInput
  description: String
  identifier: IdentifierUpdateOneWithoutBookNestedInput
  language: String
  logs: AuditLogUpdateManyWithoutBookNestedInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewUpdateManyWithoutBookNestedInput
  title: String
  userBook: UserBookUpdateManyWithoutBookNestedInput
  work: WorkUpdateOneWithoutEditionsNestedInput
}

input BookUpdateWithoutLogsInput {
  authors: AuthorUpdateManyWithoutBooksNestedInput
  coverImage: String
  covers: CoverUpdateManyWithoutBookNestedInput
  description: String
  identifier: IdentifierUpdateOneWithoutBookNestedInput
  language: String
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewUpdateManyWithoutBookNestedInput
  title: String
  userBook: UserBookUpdateManyWithoutBookNestedInput
  work: WorkUpdateOneWithoutEditionsNestedInput
}

input BookUpdateWithoutReviewsInput {
  authors: AuthorUpdateManyWithoutBooksNestedInput
  coverImage: String
  covers: CoverUpdateManyWithoutBookNestedInput
  description: String
  identifier: IdentifierUpdateOneWithoutBookNestedInput
  language: String
  logs: AuditLogUpdateManyWithoutBookNestedInput
  pageCount: Int
  publishedDate: String
  publisher: String
  title: String
  userBook: UserBookUpdateManyWithoutBookNestedInput
  work: WorkUpdateOneWithoutEditionsNestedInput
}

input BookUpdateWithoutUserBookInput {
  authors: AuthorUpdateManyWithoutBooksNestedInput
  coverImage: String
  covers: CoverUpdateManyWithoutBookNestedInput
  description: String
  identifier: IdentifierUpdateOneWithoutBookNestedInput
  language: String
  logs: AuditLogUpdateManyWithoutBookNestedInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewUpdateManyWithoutBookNestedInput
  title: String
  work: WorkUpdateOneWithoutEditionsNestedInput
}

input BookUpdateWithoutWorkInput {
  authors: AuthorUpdateManyWithoutBooksNestedInput
  coverImage: String
  covers: CoverUpdateManyWithoutBookNestedInput
  description: String
  identifier: IdentifierUpdateOneWithoutBookNestedInput
  language: String
  logs: AuditLogUpdateManyWithoutBookNestedInput
  pageCount: Int
  publishedDate: String
  publisher: String
  reviews: ReviewUpdateManyWithoutBookNestedInput
  title: String
  userBook: UserBookUpdateManyWithoutBookNestedInput
}

input BookUpsertWithWhereUniqueWithoutAuthorsInput {
  create: BookCreateWithoutAuthorsInput!
  update: BookUpdateWithoutAuthorsInput!
  where: BookWhereUniqueInput!
}

input BookUpsertWithWhereUniqueWithoutWorkInput {
  create: BookCreateWithoutWorkInput!
  update: BookUpdateWithoutWorkInput!
  where: BookWhereUniqueInput!
}

input BookUpsertWithoutLogsInput {
  create: BookCreateWithoutLogsInput!
  update: BookUpdateWithoutLogsInput!
  where: BookWhereInput
}

input BookUpsertWithoutReviewsInput {
  create: BookCreateWithoutReviewsInput!
  update: BookUpdateWithoutReviewsInput!
  where: BookWhereInput
}

input BookUpsertWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  update: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: AuthorListRelationFilter
  coverImage: StringFilter
  covers: CoverListRelationFilter
  description: StringFilter
  id: IntFilter
  identifier: IdentifierRelationFilter
  language: StringFilter
  logs: AuditLogListRelationFilter
  pageCount: IntFilter
  publishedDate: StringFilter
  publisher: StringFilter
  reviews: ReviewListRelationFilter
  title: StringFilter
  userBook: UserBookListRelationFilter
  work: WorkRelationFilter
  workId: StringFilter
}

input BookWhereUniqueInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: AuthorListRelationFilter
  coverImage: StringFilter
  covers: CoverListRelationFilter
  description: StringFilter
  id: Int
  identifier: IdentifierRelationFilter
  language: StringFilter
  logs: AuditLogListRelationFilter
  pageCount: IntFilter
  publishedDate: StringFilter
  publisher: StringFilter
  reviews: ReviewListRelationFilter
  title: StringFilter
  userBook: UserBookListRelationFilter
  work: WorkRelationFilter
  workId: StringFilter
}

input BoolFilter {
  equals: Boolean
  not: BoolFilter
}

type Comment {
  content: String
  createdAt: Timestamp!
  id: ID!
  review: Review
  reviewId: String
  user: User
  userId: String
}

type CommentCountAggregate {
  _all: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  reviewId: Int!
  userId: Int!
}

input CommentCreateInput {
  content: String
  createdAt: Timestamp
  id: String
  review: ReviewCreateNestedOneWithoutCommentsInput
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateManyReviewInput {
  content: String
  createdAt: Timestamp
  id: String
  userId: String
}

input CommentCreateManyReviewInputEnvelope {
  data: [CommentCreateManyReviewInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  content: String
  createdAt: Timestamp
  id: String
  reviewId: String
}

input CommentCreateManyUserInputEnvelope {
  data: [CommentCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutReviewInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutReviewInput!]
  create: [CommentCreateWithoutReviewInput!]
  createMany: CommentCreateManyReviewInputEnvelope
}

input CommentCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateOrConnectWithoutReviewInput {
  create: CommentCreateWithoutReviewInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutReviewInput {
  content: String
  createdAt: Timestamp
  id: String
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateWithoutUserInput {
  content: String
  createdAt: Timestamp
  id: String
  review: ReviewCreateNestedOneWithoutCommentsInput
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregate {
  content: String
  createdAt: Timestamp
  id: String
  reviewId: String
  userId: String
}

type CommentMinAggregate {
  content: String
  createdAt: Timestamp
  id: String
  reviewId: String
  userId: String
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  reviewId: StringFilter
  userId: StringFilter
}

input CommentUpdateManyMutationInput {
  content: String
  createdAt: Timestamp
  id: String
}

input CommentUpdateManyWithWhereWithoutReviewInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutReviewNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutReviewInput!]
  create: [CommentCreateWithoutReviewInput!]
  createMany: CommentCreateManyReviewInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutReviewInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutReviewInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutReviewInput!]
}

input CommentUpdateManyWithoutUserNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
}

input CommentUpdateWithWhereUniqueWithoutReviewInput {
  data: CommentUpdateWithoutReviewInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  data: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutReviewInput {
  content: String
  createdAt: Timestamp
  id: String
  user: UserUpdateOneWithoutCommentsNestedInput
}

input CommentUpdateWithoutUserInput {
  content: String
  createdAt: Timestamp
  id: String
  review: ReviewUpdateOneWithoutCommentsNestedInput
}

input CommentUpsertWithWhereUniqueWithoutReviewInput {
  create: CommentCreateWithoutReviewInput!
  update: CommentUpdateWithoutReviewInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  update: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  review: ReviewRelationFilter
  reviewId: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input CommentWhereUniqueInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: String
  review: ReviewRelationFilter
  reviewId: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

type Cover {
  book: Book
  bookId: Int
  id: ID!
  size: SIZE!
  url: String!
}

type CoverAvgAggregate {
  bookId: Float
}

type CoverCountAggregate {
  _all: Int!
  bookId: Int!
  id: Int!
  size: Int!
  url: Int!
}

input CoverCreateManyBookInput {
  id: String
  size: SIZE!
  url: String!
}

input CoverCreateManyBookInputEnvelope {
  data: [CoverCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input CoverCreateNestedManyWithoutBookInput {
  connect: [CoverWhereUniqueInput!]
  connectOrCreate: [CoverCreateOrConnectWithoutBookInput!]
  create: [CoverCreateWithoutBookInput!]
  createMany: CoverCreateManyBookInputEnvelope
}

input CoverCreateOrConnectWithoutBookInput {
  create: CoverCreateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverCreateWithoutBookInput {
  id: String
  size: SIZE!
  url: String!
}

input CoverListRelationFilter {
  every: CoverWhereInput
  none: CoverWhereInput
  some: CoverWhereInput
}

type CoverMaxAggregate {
  bookId: Int
  id: String
  size: SIZE
  url: String
}

type CoverMinAggregate {
  bookId: Int
  id: String
  size: SIZE
  url: String
}

input CoverOrderByRelationAggregateInput {
  _count: SortOrder
}

input CoverScalarWhereInput {
  AND: [CoverScalarWhereInput!]
  NOT: [CoverScalarWhereInput!]
  OR: [CoverScalarWhereInput!]
  bookId: IntFilter
  id: StringFilter
  size: EnumSIZEFilter
  url: StringFilter
}

type CoverSumAggregate {
  bookId: Int
}

input CoverUpdateManyMutationInput {
  id: String
  size: SIZE
  url: String
}

input CoverUpdateManyWithWhereWithoutBookInput {
  data: CoverUpdateManyMutationInput!
  where: CoverScalarWhereInput!
}

input CoverUpdateManyWithoutBookNestedInput {
  connect: [CoverWhereUniqueInput!]
  connectOrCreate: [CoverCreateOrConnectWithoutBookInput!]
  create: [CoverCreateWithoutBookInput!]
  createMany: CoverCreateManyBookInputEnvelope
  delete: [CoverWhereUniqueInput!]
  deleteMany: [CoverScalarWhereInput!]
  disconnect: [CoverWhereUniqueInput!]
  set: [CoverWhereUniqueInput!]
  update: [CoverUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [CoverUpdateManyWithWhereWithoutBookInput!]
  upsert: [CoverUpsertWithWhereUniqueWithoutBookInput!]
}

input CoverUpdateWithWhereUniqueWithoutBookInput {
  data: CoverUpdateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverUpdateWithoutBookInput {
  id: String
  size: SIZE
  url: String
}

input CoverUpsertWithWhereUniqueWithoutBookInput {
  create: CoverCreateWithoutBookInput!
  update: CoverUpdateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverWhereInput {
  AND: [CoverWhereInput!]
  NOT: [CoverWhereInput!]
  OR: [CoverWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  id: StringFilter
  size: EnumSIZEFilter
  url: StringFilter
}

input CoverWhereUniqueInput {
  AND: [CoverWhereInput!]
  NOT: [CoverWhereInput!]
  OR: [CoverWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  id: String
  size: EnumSIZEFilter
  url: StringFilter
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: DateTimeFilter
  notIn: [Timestamp!]
}

input EnumACTIONFilter {
  equals: ACTION
  in: [ACTION!]
  not: EnumACTIONFilter
  notIn: [ACTION!]
}

input EnumSIZEFilter {
  equals: SIZE
  in: [SIZE!]
  not: EnumSIZEFilter
  notIn: [SIZE!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: FloatFilter
  notIn: [Float!]
}

type Identifier {
  amazon: String
  book: Book
  bookId: Int!
  goodreads: String
  googleBooks: String
  isbn10: String
  isbn13: String
  openLibrary: String
}

type IdentifierAvgAggregate {
  bookId: Float
}

type IdentifierCountAggregate {
  _all: Int!
  amazon: Int!
  bookId: Int!
  goodreads: Int!
  googleBooks: Int!
  isbn10: Int!
  isbn13: Int!
  openLibrary: Int!
}

input IdentifierCreateNestedOneWithoutBookInput {
  connect: IdentifierWhereUniqueInput
  connectOrCreate: IdentifierCreateOrConnectWithoutBookInput
  create: IdentifierCreateWithoutBookInput
}

input IdentifierCreateOrConnectWithoutBookInput {
  create: IdentifierCreateWithoutBookInput!
  where: IdentifierWhereUniqueInput!
}

input IdentifierCreateWithoutBookInput {
  amazon: String
  goodreads: String
  googleBooks: String
  isbn10: String
  isbn13: String
  openLibrary: String
}

type IdentifierMaxAggregate {
  amazon: String
  bookId: Int
  goodreads: String
  googleBooks: String
  isbn10: String
  isbn13: String
  openLibrary: String
}

type IdentifierMinAggregate {
  amazon: String
  bookId: Int
  goodreads: String
  googleBooks: String
  isbn10: String
  isbn13: String
  openLibrary: String
}

input IdentifierOrderByWithRelationInput {
  amazon: SortOrderInput
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  goodreads: SortOrderInput
  googleBooks: SortOrderInput
  isbn10: SortOrderInput
  isbn13: SortOrderInput
  openLibrary: SortOrderInput
}

input IdentifierRelationFilter {
  is: IdentifierWhereInput
  isNot: IdentifierWhereInput
}

type IdentifierSumAggregate {
  bookId: Int
}

input IdentifierUpdateOneWithoutBookNestedInput {
  connect: IdentifierWhereUniqueInput
  connectOrCreate: IdentifierCreateOrConnectWithoutBookInput
  create: IdentifierCreateWithoutBookInput
  delete: IdentifierWhereInput
  disconnect: IdentifierWhereInput
  update: IdentifierUpdateToOneWithWhereWithoutBookInput
  upsert: IdentifierUpsertWithoutBookInput
}

input IdentifierUpdateToOneWithWhereWithoutBookInput {
  data: IdentifierUpdateWithoutBookInput!
  where: IdentifierWhereInput
}

input IdentifierUpdateWithoutBookInput {
  amazon: String
  goodreads: String
  googleBooks: String
  isbn10: String
  isbn13: String
  openLibrary: String
}

input IdentifierUpsertWithoutBookInput {
  create: IdentifierCreateWithoutBookInput!
  update: IdentifierUpdateWithoutBookInput!
  where: IdentifierWhereInput
}

input IdentifierWhereInput {
  AND: [IdentifierWhereInput!]
  NOT: [IdentifierWhereInput!]
  OR: [IdentifierWhereInput!]
  amazon: StringFilter
  book: BookRelationFilter
  bookId: IntFilter
  goodreads: StringFilter
  googleBooks: StringFilter
  isbn10: StringFilter
  isbn13: StringFilter
  openLibrary: StringFilter
}

input IdentifierWhereUniqueInput {
  AND: [IdentifierWhereInput!]
  NOT: [IdentifierWhereInput!]
  OR: [IdentifierWhereInput!]
  amazon: StringFilter
  book: BookRelationFilter
  bookId: Int
  goodreads: StringFilter
  googleBooks: StringFilter
  isbn10: StringFilter
  isbn13: StringFilter
  openLibrary: StringFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: IntFilter
  notIn: [Int!]
}

type JournalEntry {
  createdAt: Timestamp!
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp!
  id: ID!
  pagesRead: Int!
  readingNotes: String
  user: User
  userBook: UserBook
  userBookId: String
  userId: String
}

type JournalEntryAvgAggregate {
  currentPage: Float
  currentPercent: Float
  pagesRead: Float
}

type JournalEntryCountAggregate {
  _all: Int!
  createdAt: Int!
  currentPage: Int!
  currentPercent: Int!
  dateRead: Int!
  id: Int!
  pagesRead: Int!
  readingNotes: Int!
  userBookId: Int!
  userId: Int!
}

input JournalEntryCreateInput {
  createdAt: Timestamp
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  user: UserCreateNestedOneWithoutJournalEntriesInput
  userBook: UserBookCreateNestedOneWithoutJournalEntryInput
}

input JournalEntryCreateManyUserBookInput {
  createdAt: Timestamp
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userId: String
}

input JournalEntryCreateManyUserBookInputEnvelope {
  data: [JournalEntryCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input JournalEntryCreateManyUserInput {
  createdAt: Timestamp
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userBookId: String
}

input JournalEntryCreateManyUserInputEnvelope {
  data: [JournalEntryCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input JournalEntryCreateNestedManyWithoutUserBookInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserBookInput!]
  create: [JournalEntryCreateWithoutUserBookInput!]
  createMany: JournalEntryCreateManyUserBookInputEnvelope
}

input JournalEntryCreateNestedManyWithoutUserInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserInput!]
  create: [JournalEntryCreateWithoutUserInput!]
  createMany: JournalEntryCreateManyUserInputEnvelope
}

input JournalEntryCreateOrConnectWithoutUserBookInput {
  create: JournalEntryCreateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryCreateOrConnectWithoutUserInput {
  create: JournalEntryCreateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryCreateWithoutUserBookInput {
  createdAt: Timestamp
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  user: UserCreateNestedOneWithoutJournalEntriesInput
}

input JournalEntryCreateWithoutUserInput {
  createdAt: Timestamp
  currentPage: Int!
  currentPercent: Int!
  dateRead: Timestamp
  id: String
  pagesRead: Int!
  readingNotes: String
  userBook: UserBookCreateNestedOneWithoutJournalEntryInput
}

input JournalEntryListRelationFilter {
  every: JournalEntryWhereInput
  none: JournalEntryWhereInput
  some: JournalEntryWhereInput
}

type JournalEntryMaxAggregate {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBookId: String
  userId: String
}

type JournalEntryMinAggregate {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBookId: String
  userId: String
}

input JournalEntryOrderByRelationAggregateInput {
  _count: SortOrder
}

input JournalEntryScalarWhereInput {
  AND: [JournalEntryScalarWhereInput!]
  NOT: [JournalEntryScalarWhereInput!]
  OR: [JournalEntryScalarWhereInput!]
  createdAt: DateTimeFilter
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: StringFilter
  pagesRead: IntFilter
  readingNotes: StringFilter
  userBookId: StringFilter
  userId: StringFilter
}

type JournalEntrySumAggregate {
  currentPage: Int
  currentPercent: Int
  pagesRead: Int
}

input JournalEntryUpdateInput {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  user: UserUpdateOneWithoutJournalEntriesNestedInput
  userBook: UserBookUpdateOneWithoutJournalEntryNestedInput
}

input JournalEntryUpdateManyMutationInput {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
}

input JournalEntryUpdateManyWithWhereWithoutUserBookInput {
  data: JournalEntryUpdateManyMutationInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateManyWithWhereWithoutUserInput {
  data: JournalEntryUpdateManyMutationInput!
  where: JournalEntryScalarWhereInput!
}

input JournalEntryUpdateManyWithoutUserBookNestedInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserBookInput!]
  create: [JournalEntryCreateWithoutUserBookInput!]
  createMany: JournalEntryCreateManyUserBookInputEnvelope
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [JournalEntryUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutUserBookInput!]
}

input JournalEntryUpdateManyWithoutUserNestedInput {
  connect: [JournalEntryWhereUniqueInput!]
  connectOrCreate: [JournalEntryCreateOrConnectWithoutUserInput!]
  create: [JournalEntryCreateWithoutUserInput!]
  createMany: JournalEntryCreateManyUserInputEnvelope
  delete: [JournalEntryWhereUniqueInput!]
  deleteMany: [JournalEntryScalarWhereInput!]
  disconnect: [JournalEntryWhereUniqueInput!]
  set: [JournalEntryWhereUniqueInput!]
  update: [JournalEntryUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [JournalEntryUpdateManyWithWhereWithoutUserInput!]
  upsert: [JournalEntryUpsertWithWhereUniqueWithoutUserInput!]
}

input JournalEntryUpdateWithWhereUniqueWithoutUserBookInput {
  data: JournalEntryUpdateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpdateWithWhereUniqueWithoutUserInput {
  data: JournalEntryUpdateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpdateWithoutUserBookInput {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  user: UserUpdateOneWithoutJournalEntriesNestedInput
}

input JournalEntryUpdateWithoutUserInput {
  createdAt: Timestamp
  currentPage: Int
  currentPercent: Int
  dateRead: Timestamp
  id: String
  pagesRead: Int
  readingNotes: String
  userBook: UserBookUpdateOneWithoutJournalEntryNestedInput
}

input JournalEntryUpsertWithWhereUniqueWithoutUserBookInput {
  create: JournalEntryCreateWithoutUserBookInput!
  update: JournalEntryUpdateWithoutUserBookInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryUpsertWithWhereUniqueWithoutUserInput {
  create: JournalEntryCreateWithoutUserInput!
  update: JournalEntryUpdateWithoutUserInput!
  where: JournalEntryWhereUniqueInput!
}

input JournalEntryWhereInput {
  AND: [JournalEntryWhereInput!]
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  createdAt: DateTimeFilter
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: StringFilter
  pagesRead: IntFilter
  readingNotes: StringFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

input JournalEntryWhereUniqueInput {
  AND: [JournalEntryWhereInput!]
  NOT: [JournalEntryWhereInput!]
  OR: [JournalEntryWhereInput!]
  createdAt: DateTimeFilter
  currentPage: IntFilter
  currentPercent: IntFilter
  dateRead: DateTimeFilter
  id: String
  pagesRead: IntFilter
  readingNotes: StringFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

input LogInInput {
  email: String!
  password: String
}

type MeResponse {
  email: String
  isOAuth: Boolean
  username: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): Author!
  createBook(data: BookCreateInput!): Book!
  createComment(data: CommentCreateInput!, where: ReviewWhereUniqueInput!): Comment!
  createJournalEntry(book: BookWhereUniqueInput!, data: JournalEntryCreateInput!): JournalEntry!
  createReview(bookData: BookCreateInput!, data: ReviewDataInput!, where: BookWhereUniqueInput!): Review!
  createShelf(data: ShelfCreateInput!): Shelf!
  createUserBook(id: String!): UserBook
  deleteShelf(where: ShelfWhereUniqueInput!): Shelf!
  follow(value: Boolean!, where: UserWhereUniqueInput!): User!
  forgotPassword(email: String!): Boolean!
  importUserBooks(content: String!): Boolean!
  likeReview(value: Boolean!, where: ReviewWhereUniqueInput!): Review!
  likeUserBook(bookId: Int!): UserBook!
  login(logInInput: LogInInput!): AuthResponse!
  logout(id: String!): Boolean!
  oAuth(oAuthInput: OAuthInput!): AuthResponse!
  refreshAuth: RefreshResponse!
  register(registerInput: RegisterInput!): User!
  removeJournalEntry(where: JournalEntryWhereUniqueInput!): JournalEntry!
  removeUserBook(where: BookWhereUniqueInput!): UserBook!
  resetPassword(resetPasswordInput: ResetPasswordInput!): Boolean!
  updateEmail(data: UpdateEmailInput!): User!
  updateJournalEntry(data: JournalEntryUpdateInput!, where: JournalEntryWhereUniqueInput!): JournalEntry!
  updateReview(data: ReviewDataInput!, where: ReviewWhereUniqueInput!): Review!
  updateShelf(data: ShelfUpdateInput!, where: ShelfWhereUniqueInput!): Shelf!
  updateUser(data: UpdateUserInput!): User!
  updateUserBook(data: UserBookUpdateInput!, where: BookWhereUniqueInput!): UserBook!
  updateUserBookOrder(data: UserBookUpdateOrderInput!): [UserBook!]!
  verifyToken(token: String!): AuthResponse!
}

enum NullsOrder {
  first
  last
}

input OAuthInput {
  access_token: String!
  email: String!
  image: String!
  provider: String!
  providerAccountId: String!
  scope: String!
  token_type: String!
  type: String!
  username: String!
}

type PasswordResetTokenCountAggregate {
  _all: Int!
  email: Int!
  expires: Int!
  id: Int!
  token: Int!
}

type PasswordResetTokenMaxAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}

type PasswordResetTokenMinAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}

type Query {
  auditLogs(action: ACTION, limit: Int! = 20, offset: Int! = 0, orderBy: AuditLogOrderByWithRelationInput, where: UserBookWhereUniqueInput): ActivitiesResponse!
  book(where: BookWhereUniqueInput!): Book
  bookReview(where: ReviewUniqueInput!): Review!
  bookReviews(limit: Int! = 20, offset: Int! = 0, where: BookWhereUniqueInput!): [Review!]!
  comments(limit: Int! = 20, offset: Int! = 0, where: ReviewWhereUniqueInput!): [Comment!]!
  countJournalEntries(book: BookWhereUniqueInput): Int!
  countUserBooks(where: UserBookWhereInput): Int!
  getGoogleBook(id: String!): Book
  getMostRecentJournalEntry(book: BookWhereUniqueInput): JournalEntry
  getUserBooks(limit: Int! = 20, offset: Int! = 0, orderBy: UserBookOrderByWithRelationInput, where: UserBookWhereInput): UserBooksResponse!
  journalEntries(book: BookWhereUniqueInput, limit: Int! = 20, offset: Int! = 0): [JournalEntry!]!
  me: MeResponse!
  shelves: [Shelf!]
  user(where: UserWhereUniqueInput!): User!
  userBook(where: BookWhereUniqueInput!): UserBook
}

enum QueryMode {
  default
  insensitive
}

type RefreshResponse {
  accessToken: String!
  expiresIn: Float!
  refreshToken: String!
}

input RegisterInput {
  email: String!
  password: String!
  username: String!
}

input ResetPasswordInput {
  password: String!
  token: String!
}

type Review {
  _count: ReviewCount!
  book: Book
  bookId: Int
  commentCount: Int!
  comments: [Comment!]
  content: String
  createdAt: Timestamp!
  id: ID!
  likeCount: Int!
  liked: Boolean!
  likedBy: [User!]
  spoilers: Boolean!
  user: User
  userBook: UserBook
  userBookId: String
  userId: String
}

type ReviewAvgAggregate {
  bookId: Float
  likeCount: Float
}

type ReviewCount {
  comments: Int!
  likedBy: Int!
}

type ReviewCountAggregate {
  _all: Int!
  bookId: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  likeCount: Int!
  spoilers: Int!
  userBookId: Int!
  userId: Int!
}

input ReviewCreateManyBookInput {
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  userBookId: String
  userId: String
}

input ReviewCreateManyBookInputEnvelope {
  data: [ReviewCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input ReviewCreateManyUserBookInput {
  bookId: Int
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  userId: String
}

input ReviewCreateManyUserBookInputEnvelope {
  data: [ReviewCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input ReviewCreateManyUserInput {
  bookId: Int
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  userBookId: String
}

input ReviewCreateManyUserInputEnvelope {
  data: [ReviewCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ReviewCreateNestedManyWithoutBookInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutBookInput!]
  create: [ReviewCreateWithoutBookInput!]
  createMany: ReviewCreateManyBookInputEnvelope
}

input ReviewCreateNestedManyWithoutLikedByInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutLikedByInput!]
  create: [ReviewCreateWithoutLikedByInput!]
}

input ReviewCreateNestedManyWithoutUserBookInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutUserBookInput!]
  create: [ReviewCreateWithoutUserBookInput!]
  createMany: ReviewCreateManyUserBookInputEnvelope
}

input ReviewCreateNestedManyWithoutUserInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutUserInput!]
  create: [ReviewCreateWithoutUserInput!]
  createMany: ReviewCreateManyUserInputEnvelope
}

input ReviewCreateNestedOneWithoutCommentsInput {
  connect: ReviewWhereUniqueInput
  connectOrCreate: ReviewCreateOrConnectWithoutCommentsInput
  create: ReviewCreateWithoutCommentsInput
}

input ReviewCreateOrConnectWithoutBookInput {
  create: ReviewCreateWithoutBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewCreateOrConnectWithoutCommentsInput {
  create: ReviewCreateWithoutCommentsInput!
  where: ReviewWhereUniqueInput!
}

input ReviewCreateOrConnectWithoutLikedByInput {
  create: ReviewCreateWithoutLikedByInput!
  where: ReviewWhereUniqueInput!
}

input ReviewCreateOrConnectWithoutUserBookInput {
  create: ReviewCreateWithoutUserBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewCreateOrConnectWithoutUserInput {
  create: ReviewCreateWithoutUserInput!
  where: ReviewWhereUniqueInput!
}

input ReviewCreateWithoutBookInput {
  comments: CommentCreateNestedManyWithoutReviewInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserCreateNestedManyWithoutLikedReviewsInput
  spoilers: Boolean
  user: UserCreateNestedOneWithoutReviewsInput
  userBook: UserBookCreateNestedOneWithoutReviewsInput
}

input ReviewCreateWithoutCommentsInput {
  book: BookCreateNestedOneWithoutReviewsInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserCreateNestedManyWithoutLikedReviewsInput
  spoilers: Boolean
  user: UserCreateNestedOneWithoutReviewsInput
  userBook: UserBookCreateNestedOneWithoutReviewsInput
}

input ReviewCreateWithoutLikedByInput {
  book: BookCreateNestedOneWithoutReviewsInput
  comments: CommentCreateNestedManyWithoutReviewInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  user: UserCreateNestedOneWithoutReviewsInput
  userBook: UserBookCreateNestedOneWithoutReviewsInput
}

input ReviewCreateWithoutUserBookInput {
  book: BookCreateNestedOneWithoutReviewsInput
  comments: CommentCreateNestedManyWithoutReviewInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserCreateNestedManyWithoutLikedReviewsInput
  spoilers: Boolean
  user: UserCreateNestedOneWithoutReviewsInput
}

input ReviewCreateWithoutUserInput {
  book: BookCreateNestedOneWithoutReviewsInput
  comments: CommentCreateNestedManyWithoutReviewInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserCreateNestedManyWithoutLikedReviewsInput
  spoilers: Boolean
  userBook: UserBookCreateNestedOneWithoutReviewsInput
}

input ReviewDataInput {
  content: String
  rating: Float
  spoilers: Boolean
}

input ReviewListRelationFilter {
  every: ReviewWhereInput
  none: ReviewWhereInput
  some: ReviewWhereInput
}

type ReviewMaxAggregate {
  bookId: Int
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  userBookId: String
  userId: String
}

type ReviewMinAggregate {
  bookId: Int
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  userBookId: String
  userId: String
}

input ReviewOrderByRelationAggregateInput {
  _count: SortOrder
}

input ReviewRelationFilter {
  is: ReviewWhereInput
  isNot: ReviewWhereInput
}

input ReviewScalarWhereInput {
  AND: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  bookId: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  likeCount: IntFilter
  spoilers: BoolFilter
  userBookId: StringFilter
  userId: StringFilter
}

type ReviewSumAggregate {
  bookId: Int
  likeCount: Int
}

input ReviewUniqueInput {
  bookId: Float
  id: String
}

input ReviewUpdateManyMutationInput {
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
}

input ReviewUpdateManyWithWhereWithoutBookInput {
  data: ReviewUpdateManyMutationInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateManyWithWhereWithoutLikedByInput {
  data: ReviewUpdateManyMutationInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateManyWithWhereWithoutUserBookInput {
  data: ReviewUpdateManyMutationInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateManyWithWhereWithoutUserInput {
  data: ReviewUpdateManyMutationInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateManyWithoutBookNestedInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutBookInput!]
  create: [ReviewCreateWithoutBookInput!]
  createMany: ReviewCreateManyBookInputEnvelope
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [ReviewUpdateManyWithWhereWithoutBookInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutBookInput!]
}

input ReviewUpdateManyWithoutLikedByNestedInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutLikedByInput!]
  create: [ReviewCreateWithoutLikedByInput!]
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [ReviewUpdateManyWithWhereWithoutLikedByInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutLikedByInput!]
}

input ReviewUpdateManyWithoutUserBookNestedInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutUserBookInput!]
  create: [ReviewCreateWithoutUserBookInput!]
  createMany: ReviewCreateManyUserBookInputEnvelope
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [ReviewUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUserBookInput!]
}

input ReviewUpdateManyWithoutUserNestedInput {
  connect: [ReviewWhereUniqueInput!]
  connectOrCreate: [ReviewCreateOrConnectWithoutUserInput!]
  create: [ReviewCreateWithoutUserInput!]
  createMany: ReviewCreateManyUserInputEnvelope
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ReviewUpdateManyWithWhereWithoutUserInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUserInput!]
}

input ReviewUpdateOneWithoutCommentsNestedInput {
  connect: ReviewWhereUniqueInput
  connectOrCreate: ReviewCreateOrConnectWithoutCommentsInput
  create: ReviewCreateWithoutCommentsInput
  delete: ReviewWhereInput
  disconnect: ReviewWhereInput
  update: ReviewUpdateToOneWithWhereWithoutCommentsInput
  upsert: ReviewUpsertWithoutCommentsInput
}

input ReviewUpdateToOneWithWhereWithoutCommentsInput {
  data: ReviewUpdateWithoutCommentsInput!
  where: ReviewWhereInput
}

input ReviewUpdateWithWhereUniqueWithoutBookInput {
  data: ReviewUpdateWithoutBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithWhereUniqueWithoutLikedByInput {
  data: ReviewUpdateWithoutLikedByInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithWhereUniqueWithoutUserBookInput {
  data: ReviewUpdateWithoutUserBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithWhereUniqueWithoutUserInput {
  data: ReviewUpdateWithoutUserInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithoutBookInput {
  comments: CommentUpdateManyWithoutReviewNestedInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserUpdateManyWithoutLikedReviewsNestedInput
  spoilers: Boolean
  user: UserUpdateOneWithoutReviewsNestedInput
  userBook: UserBookUpdateOneWithoutReviewsNestedInput
}

input ReviewUpdateWithoutCommentsInput {
  book: BookUpdateOneWithoutReviewsNestedInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserUpdateManyWithoutLikedReviewsNestedInput
  spoilers: Boolean
  user: UserUpdateOneWithoutReviewsNestedInput
  userBook: UserBookUpdateOneWithoutReviewsNestedInput
}

input ReviewUpdateWithoutLikedByInput {
  book: BookUpdateOneWithoutReviewsNestedInput
  comments: CommentUpdateManyWithoutReviewNestedInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  spoilers: Boolean
  user: UserUpdateOneWithoutReviewsNestedInput
  userBook: UserBookUpdateOneWithoutReviewsNestedInput
}

input ReviewUpdateWithoutUserBookInput {
  book: BookUpdateOneWithoutReviewsNestedInput
  comments: CommentUpdateManyWithoutReviewNestedInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserUpdateManyWithoutLikedReviewsNestedInput
  spoilers: Boolean
  user: UserUpdateOneWithoutReviewsNestedInput
}

input ReviewUpdateWithoutUserInput {
  book: BookUpdateOneWithoutReviewsNestedInput
  comments: CommentUpdateManyWithoutReviewNestedInput
  content: String
  createdAt: Timestamp
  id: String
  likeCount: Int
  likedBy: UserUpdateManyWithoutLikedReviewsNestedInput
  spoilers: Boolean
  userBook: UserBookUpdateOneWithoutReviewsNestedInput
}

input ReviewUpsertWithWhereUniqueWithoutBookInput {
  create: ReviewCreateWithoutBookInput!
  update: ReviewUpdateWithoutBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutLikedByInput {
  create: ReviewCreateWithoutLikedByInput!
  update: ReviewUpdateWithoutLikedByInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutUserBookInput {
  create: ReviewCreateWithoutUserBookInput!
  update: ReviewUpdateWithoutUserBookInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutUserInput {
  create: ReviewCreateWithoutUserInput!
  update: ReviewUpdateWithoutUserInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithoutCommentsInput {
  create: ReviewCreateWithoutCommentsInput!
  update: ReviewUpdateWithoutCommentsInput!
  where: ReviewWhereInput
}

input ReviewWhereInput {
  AND: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  comments: CommentListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  likeCount: IntFilter
  likedBy: UserListRelationFilter
  spoilers: BoolFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

input ReviewWhereUniqueInput {
  AND: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  comments: CommentListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: String
  likeCount: IntFilter
  likedBy: UserListRelationFilter
  spoilers: BoolFilter
  user: UserRelationFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userId: StringFilter
}

enum SIZE {
  LARGE
  MEDIUM
  SMALL
}

type Shelf {
  _count: ShelfCount!
  dateTime: String
  id: ID!
  name: String!
  user: User
  userBooks: [UserBookShelves!]
  userId: String
}

type ShelfCount {
  userBooks: Int!
}

type ShelfCountAggregate {
  _all: Int!
  dateTime: Int!
  id: Int!
  name: Int!
  userId: Int!
}

input ShelfCreateInput {
  dateTime: String
  id: String
  name: String!
  user: UserCreateNestedOneWithoutShelvesInput
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfCreateManyUserInput {
  dateTime: String
  id: String
  name: String!
}

input ShelfCreateManyUserInputEnvelope {
  data: [ShelfCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ShelfCreateNestedManyWithoutUserInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
}

input ShelfCreateNestedOneWithoutUserBooksInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
}

input ShelfCreateOrConnectWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateOrConnectWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String!
  user: UserCreateNestedOneWithoutShelvesInput
}

input ShelfCreateWithoutUserInput {
  dateTime: String
  id: String
  name: String!
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfIdentifierCompoundUniqueInput {
  name: String!
  userId: String!
}

input ShelfListRelationFilter {
  every: ShelfWhereInput
  none: ShelfWhereInput
  some: ShelfWhereInput
}

type ShelfMaxAggregate {
  dateTime: String
  id: String
  name: String
  userId: String
}

type ShelfMinAggregate {
  dateTime: String
  id: String
  name: String
  userId: String
}

input ShelfOrderByRelationAggregateInput {
  _count: SortOrder
}

input ShelfRelationFilter {
  is: ShelfWhereInput
  isNot: ShelfWhereInput
}

input ShelfScalarWhereInput {
  AND: [ShelfScalarWhereInput!]
  NOT: [ShelfScalarWhereInput!]
  OR: [ShelfScalarWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  userId: StringFilter
}

input ShelfUpdateInput {
  dateTime: String
  id: String
  name: String
  user: UserUpdateOneWithoutShelvesNestedInput
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpdateManyMutationInput {
  dateTime: String
  id: String
  name: String
}

input ShelfUpdateManyWithWhereWithoutUserInput {
  data: ShelfUpdateManyMutationInput!
  where: ShelfScalarWhereInput!
}

input ShelfUpdateManyWithoutUserNestedInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
  delete: [ShelfWhereUniqueInput!]
  deleteMany: [ShelfScalarWhereInput!]
  disconnect: [ShelfWhereUniqueInput!]
  set: [ShelfWhereUniqueInput!]
  update: [ShelfUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ShelfUpdateManyWithWhereWithoutUserInput!]
  upsert: [ShelfUpsertWithWhereUniqueWithoutUserInput!]
}

input ShelfUpdateOneRequiredWithoutUserBooksNestedInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
  update: ShelfUpdateToOneWithWhereWithoutUserBooksInput
  upsert: ShelfUpsertWithoutUserBooksInput
}

input ShelfUpdateToOneWithWhereWithoutUserBooksInput {
  data: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfUpdateWithWhereUniqueWithoutUserInput {
  data: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpdateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String
  user: UserUpdateOneWithoutShelvesNestedInput
}

input ShelfUpdateWithoutUserInput {
  dateTime: String
  id: String
  name: String
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpsertWithWhereUniqueWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  update: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpsertWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  update: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfWhereInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  user: UserRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

input ShelfWhereUniqueInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: String
  identifier: ShelfIdentifierCompoundUniqueInput
  name: StringFilter
  user: UserRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: StringFilter
  notIn: [String!]
  startsWith: String
}

input StringListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input UpdateEmailInput {
  code: String!
  email: String!
  token: String!
}

input UpdateUserInput {
  email: String
  newPassword: String
  password: String
  username: String
}

type User {
  _count: UserCount!
  accounts: [Account!]
  auditLogs: [AuditLog!]
  comments: [Comment!]
  createdAt: Timestamp!
  email: String!
  emailVerified: Timestamp
  followerCount: Float!
  followers: [User!]
  following: [User!]
  followingCount: Float!
  id: ID!
  image: String
  isFollowing: Boolean!
  journalEntries: [JournalEntry!]
  likedReviews: [Review!]
  reviews: [Review!]
  shelves: [Shelf!]
  updatedAt: Timestamp!
  userBooks: [UserBook!]
  username: String
}

type UserBook {
  _count: UserBookCount!
  book: Book
  bookId: Int!
  createdAt: Timestamp!
  id: ID!
  journalEntry: [JournalEntry!]
  order: Int!
  rating: Float
  reviews: [Review!]
  shelves: [UserBookShelves!]
  status: String!
  updatedAt: Timestamp!
  user: User
  userId: String!
}

type UserBookAvgAggregate {
  bookId: Float
  order: Float
  rating: Float
}

type UserBookCount {
  journalEntry: Int!
  reviews: Int!
  shelves: Int!
}

type UserBookCountAggregate {
  _all: Int!
  bookId: Int!
  createdAt: Int!
  id: Int!
  order: Int!
  rating: Int!
  status: Int!
  updatedAt: Int!
  userId: Int!
}

input UserBookCreateManyBookInput {
  createdAt: Timestamp
  id: String
  order: Int!
  rating: Float
  status: String!
  updatedAt: Timestamp
  userId: String!
}

input UserBookCreateManyBookInputEnvelope {
  data: [UserBookCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input UserBookCreateManyUserInput {
  bookId: Int!
  createdAt: Timestamp
  id: String
  order: Int!
  rating: Float
  status: String!
  updatedAt: Timestamp
}

input UserBookCreateManyUserInputEnvelope {
  data: [UserBookCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserBookCreateNestedManyWithoutBookInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutBookInput!]
  create: [UserBookCreateWithoutBookInput!]
  createMany: UserBookCreateManyBookInputEnvelope
}

input UserBookCreateNestedManyWithoutUserInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
}

input UserBookCreateNestedOneWithoutJournalEntryInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutJournalEntryInput
  create: UserBookCreateWithoutJournalEntryInput
}

input UserBookCreateNestedOneWithoutReviewsInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutReviewsInput
  create: UserBookCreateWithoutReviewsInput
}

input UserBookCreateNestedOneWithoutShelvesInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
}

input UserBookCreateOrConnectWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutJournalEntryInput {
  create: UserBookCreateWithoutJournalEntryInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutReviewsInput {
  create: UserBookCreateWithoutReviewsInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateWithoutBookInput {
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  order: Int!
  rating: Float
  reviews: ReviewCreateNestedManyWithoutUserBookInput
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutJournalEntryInput {
  book: BookCreateNestedOneWithoutUserBookInput
  createdAt: Timestamp
  id: String
  order: Int!
  rating: Float
  reviews: ReviewCreateNestedManyWithoutUserBookInput
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutReviewsInput {
  book: BookCreateNestedOneWithoutUserBookInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  order: Int!
  rating: Float
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutShelvesInput {
  book: BookCreateNestedOneWithoutUserBookInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  order: Int!
  rating: Float
  reviews: ReviewCreateNestedManyWithoutUserBookInput
  status: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput
}

input UserBookCreateWithoutUserInput {
  book: BookCreateNestedOneWithoutUserBookInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryCreateNestedManyWithoutUserBookInput
  order: Int!
  rating: Float
  reviews: ReviewCreateNestedManyWithoutUserBookInput
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: String!
  updatedAt: Timestamp
}

input UserBookIdentifierCompoundUniqueInput {
  bookId: Int!
  userId: String!
}

input UserBookListRelationFilter {
  every: UserBookWhereInput
  none: UserBookWhereInput
  some: UserBookWhereInput
}

type UserBookMaxAggregate {
  bookId: Int
  createdAt: Timestamp
  id: String
  order: Int
  rating: Float
  status: String
  updatedAt: Timestamp
  userId: String
}

type UserBookMinAggregate {
  bookId: Int
  createdAt: Timestamp
  id: String
  order: Int
  rating: Float
  status: String
  updatedAt: Timestamp
  userId: String
}

input UserBookOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserBookOrderByWithRelationInput {
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  journalEntry: JournalEntryOrderByRelationAggregateInput
  order: SortOrder
  rating: SortOrderInput
  reviews: ReviewOrderByRelationAggregateInput
  shelves: UserBookShelvesOrderByRelationAggregateInput
  status: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input UserBookRelationFilter {
  is: UserBookWhereInput
  isNot: UserBookWhereInput
}

input UserBookScalarWhereInput {
  AND: [UserBookScalarWhereInput!]
  NOT: [UserBookScalarWhereInput!]
  OR: [UserBookScalarWhereInput!]
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  order: IntFilter
  rating: FloatFilter
  status: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

type UserBookShelves {
  shelf: Shelf!
  shelfId: String!
  userBook: UserBook!
  userBookId: String!
}

type UserBookShelvesCountAggregate {
  _all: Int!
  shelfId: Int!
  userBookId: Int!
}

input UserBookShelvesCreateManyShelfInput {
  userBookId: String!
}

input UserBookShelvesCreateManyShelfInputEnvelope {
  data: [UserBookShelvesCreateManyShelfInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateManyUserBookInput {
  shelfId: String!
}

input UserBookShelvesCreateManyUserBookInputEnvelope {
  data: [UserBookShelvesCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateNestedManyWithoutShelfInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
}

input UserBookShelvesCreateNestedManyWithoutUserBookInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
}

input UserBookShelvesCreateOrConnectWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateOrConnectWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateWithoutShelfInput {
  userBook: UserBookCreateNestedOneWithoutShelvesInput!
}

input UserBookShelvesCreateWithoutUserBookInput {
  shelf: ShelfCreateNestedOneWithoutUserBooksInput!
}

input UserBookShelvesListRelationFilter {
  every: UserBookShelvesWhereInput
  none: UserBookShelvesWhereInput
  some: UserBookShelvesWhereInput
}

type UserBookShelvesMaxAggregate {
  shelfId: String
  userBookId: String
}

type UserBookShelvesMinAggregate {
  shelfId: String
  userBookId: String
}

input UserBookShelvesOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserBookShelvesScalarWhereInput {
  AND: [UserBookShelvesScalarWhereInput!]
  NOT: [UserBookShelvesScalarWhereInput!]
  OR: [UserBookShelvesScalarWhereInput!]
  shelfId: StringFilter
  userBookId: StringFilter
}

input UserBookShelvesUncheckedUpdateManyWithoutShelfInput {
  userBookId: String
}

input UserBookShelvesUncheckedUpdateManyWithoutUserBookInput {
  shelfId: String
}

input UserBookShelvesUpdateManyWithWhereWithoutShelfInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutShelfInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithWhereWithoutUserBookInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutUserBookInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithoutShelfNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutShelfInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput!]
}

input UserBookShelvesUpdateManyWithoutUserBookNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput!]
}

input UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput {
  data: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput {
  data: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithoutShelfInput {
  userBook: UserBookUpdateOneRequiredWithoutShelvesNestedInput
}

input UserBookShelvesUpdateWithoutUserBookInput {
  shelf: ShelfUpdateOneRequiredWithoutUserBooksNestedInput
}

input UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  update: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  update: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUserBookIdShelfIdCompoundUniqueInput {
  shelfId: String!
  userBookId: String!
}

input UserBookShelvesWhereInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfRelationFilter
  shelfId: StringFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
}

input UserBookShelvesWhereUniqueInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfRelationFilter
  shelfId: StringFilter
  userBook: UserBookRelationFilter
  userBookId: StringFilter
  userBookId_shelfId: UserBookShelvesUserBookIdShelfIdCompoundUniqueInput
}

type UserBookSumAggregate {
  bookId: Int
  order: Int
  rating: Float
}

input UserBookUpdateInput {
  rating: Float
  shelves: [String!]
  status: String
}

input UserBookUpdateManyMutationInput {
  createdAt: Timestamp
  id: String
  order: Int
  rating: Float
  status: String
  updatedAt: Timestamp
}

input UserBookUpdateManyWithWhereWithoutBookInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithWhereWithoutUserInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithoutBookNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutBookInput!]
  create: [UserBookCreateWithoutBookInput!]
  createMany: UserBookCreateManyBookInputEnvelope
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutBookInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutBookInput!]
}

input UserBookUpdateManyWithoutUserNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutUserInput!]
}

input UserBookUpdateOneRequiredWithoutShelvesNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
  update: UserBookUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserBookUpsertWithoutShelvesInput
}

input UserBookUpdateOneWithoutJournalEntryNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutJournalEntryInput
  create: UserBookCreateWithoutJournalEntryInput
  delete: UserBookWhereInput
  disconnect: UserBookWhereInput
  update: UserBookUpdateToOneWithWhereWithoutJournalEntryInput
  upsert: UserBookUpsertWithoutJournalEntryInput
}

input UserBookUpdateOneWithoutReviewsNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutReviewsInput
  create: UserBookCreateWithoutReviewsInput
  delete: UserBookWhereInput
  disconnect: UserBookWhereInput
  update: UserBookUpdateToOneWithWhereWithoutReviewsInput
  upsert: UserBookUpsertWithoutReviewsInput
}

input UserBookUpdateOrderInput {
  items: [BookItemInput!]
}

input UserBookUpdateToOneWithWhereWithoutJournalEntryInput {
  data: UserBookUpdateWithoutJournalEntryInput!
  where: UserBookWhereInput
}

input UserBookUpdateToOneWithWhereWithoutReviewsInput {
  data: UserBookUpdateWithoutReviewsInput!
  where: UserBookWhereInput
}

input UserBookUpdateToOneWithWhereWithoutShelvesInput {
  data: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookUpdateWithWhereUniqueWithoutBookInput {
  data: UserBookUpdateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithWhereUniqueWithoutUserInput {
  data: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithoutBookInput {
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  order: Int
  rating: Float
  reviews: ReviewUpdateManyWithoutUserBookNestedInput
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
  updatedAt: Timestamp
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutJournalEntryInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  createdAt: Timestamp
  id: String
  order: Int
  rating: Float
  reviews: ReviewUpdateManyWithoutUserBookNestedInput
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
  updatedAt: Timestamp
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutReviewsInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  order: Int
  rating: Float
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
  updatedAt: Timestamp
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutShelvesInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  order: Int
  rating: Float
  reviews: ReviewUpdateManyWithoutUserBookNestedInput
  status: String
  updatedAt: Timestamp
  user: UserUpdateOneWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutUserInput {
  book: BookUpdateOneWithoutUserBookNestedInput
  createdAt: Timestamp
  id: String
  journalEntry: JournalEntryUpdateManyWithoutUserBookNestedInput
  order: Int
  rating: Float
  reviews: ReviewUpdateManyWithoutUserBookNestedInput
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: String
  updatedAt: Timestamp
}

input UserBookUpsertWithWhereUniqueWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  update: UserBookUpdateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpsertWithWhereUniqueWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  update: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpsertWithoutJournalEntryInput {
  create: UserBookCreateWithoutJournalEntryInput!
  update: UserBookUpdateWithoutJournalEntryInput!
  where: UserBookWhereInput
}

input UserBookUpsertWithoutReviewsInput {
  create: UserBookCreateWithoutReviewsInput!
  update: UserBookUpdateWithoutReviewsInput!
  where: UserBookWhereInput
}

input UserBookUpsertWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  update: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookWhereInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  journalEntry: JournalEntryListRelationFilter
  order: IntFilter
  rating: FloatFilter
  reviews: ReviewListRelationFilter
  shelves: UserBookShelvesListRelationFilter
  status: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input UserBookWhereUniqueInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
  id: String
  identifier: UserBookIdentifierCompoundUniqueInput
  journalEntry: JournalEntryListRelationFilter
  order: IntFilter
  rating: FloatFilter
  reviews: ReviewListRelationFilter
  shelves: UserBookShelvesListRelationFilter
  status: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

type UserBooksResponse {
  hasMore: Boolean!
  totalBooks: Float!
  userBooks: [UserBook!]
}

type UserCount {
  accounts: Int!
  auditLogs: Int!
  comments: Int!
  followers: Int!
  following: Int!
  journalEntries: Int!
  likedReviews: Int!
  reviews: Int!
  shelves: Int!
  userBooks: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  id: Int!
  image: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateNestedManyWithoutFollowersInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowersInput!]
  create: [UserCreateWithoutFollowersInput!]
}

input UserCreateNestedManyWithoutFollowingInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowingInput!]
  create: [UserCreateWithoutFollowingInput!]
}

input UserCreateNestedManyWithoutLikedReviewsInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutLikedReviewsInput!]
  create: [UserCreateWithoutLikedReviewsInput!]
}

input UserCreateNestedOneWithoutAuditLogsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAuditLogsInput
  create: UserCreateWithoutAuditLogsInput
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutJournalEntriesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutJournalEntriesInput
  create: UserCreateWithoutJournalEntriesInput
}

input UserCreateNestedOneWithoutReviewsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReviewsInput
  create: UserCreateWithoutReviewsInput
}

input UserCreateNestedOneWithoutShelvesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
}

input UserCreateNestedOneWithoutUserBooksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
}

input UserCreateOrConnectWithoutAuditLogsInput {
  create: UserCreateWithoutAuditLogsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFollowingInput {
  create: UserCreateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutJournalEntriesInput {
  create: UserCreateWithoutJournalEntriesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLikedReviewsInput {
  create: UserCreateWithoutLikedReviewsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAuditLogsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutCommentsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutFollowersInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutFollowingInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutJournalEntriesInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutLikedReviewsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutReviewsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutShelvesInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutUserBooksInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  auditLogs: AuditLogCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  followers: UserCreateNestedManyWithoutFollowingInput
  following: UserCreateNestedManyWithoutFollowersInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryCreateNestedManyWithoutUserInput
  likedReviews: ReviewCreateNestedManyWithoutLikedByInput
  reviews: ReviewCreateNestedManyWithoutUserInput
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  username: String
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  id: String
  image: String
  updatedAt: Timestamp
  username: String
}

type UserMinAggregate {
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  id: String
  image: String
  updatedAt: Timestamp
  username: String
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithRelationInput {
  accounts: AccountOrderByRelationAggregateInput
  auditLogs: AuditLogOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  followers: UserOrderByRelationAggregateInput
  following: UserOrderByRelationAggregateInput
  hashedPassword: SortOrderInput
  hashedRefreshToken: SortOrderInput
  id: SortOrder
  image: SortOrderInput
  journalEntries: JournalEntryOrderByRelationAggregateInput
  likedReviews: ReviewOrderByRelationAggregateInput
  reviews: ReviewOrderByRelationAggregateInput
  shelves: ShelfOrderByRelationAggregateInput
  updatedAt: SortOrder
  userBooks: UserBookOrderByRelationAggregateInput
  username: SortOrderInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: StringFilter
  image: StringFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserUpdateManyMutationInput {
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  updatedAt: Timestamp
  username: String
}

input UserUpdateManyWithWhereWithoutFollowersInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithWhereWithoutFollowingInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithWhereWithoutLikedReviewsInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutFollowersNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowersInput!]
  create: [UserCreateWithoutFollowersInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowersInput!]
  updateMany: [UserUpdateManyWithWhereWithoutFollowersInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowersInput!]
}

input UserUpdateManyWithoutFollowingNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutFollowingInput!]
  create: [UserCreateWithoutFollowingInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowingInput!]
  updateMany: [UserUpdateManyWithWhereWithoutFollowingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowingInput!]
}

input UserUpdateManyWithoutLikedReviewsNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutLikedReviewsInput!]
  create: [UserCreateWithoutLikedReviewsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedReviewsInput!]
  updateMany: [UserUpdateManyWithWhereWithoutLikedReviewsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedReviewsInput!]
}

input UserUpdateOneWithoutAuditLogsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAuditLogsInput
  create: UserCreateWithoutAuditLogsInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutAuditLogsInput
  upsert: UserUpsertWithoutAuditLogsInput
}

input UserUpdateOneWithoutCommentsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneWithoutJournalEntriesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutJournalEntriesInput
  create: UserCreateWithoutJournalEntriesInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutJournalEntriesInput
  upsert: UserUpsertWithoutJournalEntriesInput
}

input UserUpdateOneWithoutReviewsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutReviewsInput
  create: UserCreateWithoutReviewsInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutReviewsInput
  upsert: UserUpsertWithoutReviewsInput
}

input UserUpdateOneWithoutShelvesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserUpsertWithoutShelvesInput
}

input UserUpdateOneWithoutUserBooksNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutUserBooksInput
  upsert: UserUpsertWithoutUserBooksInput
}

input UserUpdateToOneWithWhereWithoutAuditLogsInput {
  data: UserUpdateWithoutAuditLogsInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutCommentsInput {
  data: UserUpdateWithoutCommentsInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutJournalEntriesInput {
  data: UserUpdateWithoutJournalEntriesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutReviewsInput {
  data: UserUpdateWithoutReviewsInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutShelvesInput {
  data: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutUserBooksInput {
  data: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserUpdateWithWhereUniqueWithoutFollowersInput {
  data: UserUpdateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithWhereUniqueWithoutFollowingInput {
  data: UserUpdateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithWhereUniqueWithoutLikedReviewsInput {
  data: UserUpdateWithoutLikedReviewsInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutAuditLogsInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutCommentsInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutFollowersInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutFollowingInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutJournalEntriesInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutLikedReviewsInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutReviewsInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutShelvesInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutUserBooksInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  auditLogs: AuditLogUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  followers: UserUpdateManyWithoutFollowingNestedInput
  following: UserUpdateManyWithoutFollowersNestedInput
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  image: String
  journalEntries: JournalEntryUpdateManyWithoutUserNestedInput
  likedReviews: ReviewUpdateManyWithoutLikedByNestedInput
  reviews: ReviewUpdateManyWithoutUserNestedInput
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  username: String
}

input UserUpsertWithWhereUniqueWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput!
  update: UserUpdateWithoutFollowersInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutFollowingInput {
  create: UserCreateWithoutFollowingInput!
  update: UserUpdateWithoutFollowingInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutLikedReviewsInput {
  create: UserCreateWithoutLikedReviewsInput!
  update: UserUpdateWithoutLikedReviewsInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutAuditLogsInput {
  create: UserCreateWithoutAuditLogsInput!
  update: UserUpdateWithoutAuditLogsInput!
  where: UserWhereInput
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
  where: UserWhereInput
}

input UserUpsertWithoutJournalEntriesInput {
  create: UserCreateWithoutJournalEntriesInput!
  update: UserUpdateWithoutJournalEntriesInput!
  where: UserWhereInput
}

input UserUpsertWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput!
  update: UserUpdateWithoutReviewsInput!
  where: UserWhereInput
}

input UserUpsertWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  update: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpsertWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  update: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  auditLogs: AuditLogListRelationFilter
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeFilter
  followers: UserListRelationFilter
  following: UserListRelationFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: StringFilter
  image: StringFilter
  journalEntries: JournalEntryListRelationFilter
  likedReviews: ReviewListRelationFilter
  reviews: ReviewListRelationFilter
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  auditLogs: AuditLogListRelationFilter
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: String
  emailVerified: DateTimeFilter
  followers: UserListRelationFilter
  following: UserListRelationFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: String
  image: StringFilter
  journalEntries: JournalEntryListRelationFilter
  likedReviews: ReviewListRelationFilter
  reviews: ReviewListRelationFilter
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: String
}

type VerificationTokenCountAggregate {
  _all: Int!
  email: Int!
  existingEmail: Int!
  expires: Int!
  id: Int!
  token: Int!
}

type VerificationTokenMaxAggregate {
  email: String
  existingEmail: String
  expires: Timestamp
  id: String
  token: String
}

type VerificationTokenMinAggregate {
  email: String
  existingEmail: String
  expires: Timestamp
  id: String
  token: String
}

type Work {
  _count: WorkCount!
  authors: [Author!]
  averageRating: Float
  categories: [String!]
  description: String
  editions: [Book!]
  id: ID!
  mainEditionId: Int
  ratingsCount: Int
  title: String!
}

type WorkAvgAggregate {
  averageRating: Float
  mainEditionId: Float
  ratingsCount: Float
}

type WorkCount {
  authors: Int!
  editions: Int!
}

type WorkCountAggregate {
  _all: Int!
  averageRating: Int!
  categories: Int!
  description: Int!
  id: Int!
  mainEditionId: Int!
  ratingsCount: Int!
  title: Int!
}

input WorkCreateNestedManyWithoutAuthorsInput {
  connect: [WorkWhereUniqueInput!]
  connectOrCreate: [WorkCreateOrConnectWithoutAuthorsInput!]
  create: [WorkCreateWithoutAuthorsInput!]
}

input WorkCreateNestedOneWithoutEditionsInput {
  connect: WorkWhereUniqueInput
  connectOrCreate: WorkCreateOrConnectWithoutEditionsInput
  create: WorkCreateWithoutEditionsInput
}

input WorkCreateOrConnectWithoutAuthorsInput {
  create: WorkCreateWithoutAuthorsInput!
  where: WorkWhereUniqueInput!
}

input WorkCreateOrConnectWithoutEditionsInput {
  create: WorkCreateWithoutEditionsInput!
  where: WorkWhereUniqueInput!
}

input WorkCreateWithoutAuthorsInput {
  averageRating: Float
  categories: [String!]
  description: String
  editions: BookCreateNestedManyWithoutWorkInput
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String!
}

input WorkCreateWithoutEditionsInput {
  authors: AuthorCreateNestedManyWithoutWorksInput
  averageRating: Float
  categories: [String!]
  description: String
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String!
}

input WorkListRelationFilter {
  every: WorkWhereInput
  none: WorkWhereInput
  some: WorkWhereInput
}

type WorkMaxAggregate {
  averageRating: Float
  description: String
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String
}

type WorkMinAggregate {
  averageRating: Float
  description: String
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String
}

input WorkOrderByWithRelationInput {
  authors: AuthorOrderByRelationAggregateInput
  averageRating: SortOrderInput
  categories: SortOrder
  description: SortOrderInput
  editions: BookOrderByRelationAggregateInput
  id: SortOrder
  mainEditionId: SortOrderInput
  ratingsCount: SortOrderInput
  title: SortOrder
}

input WorkRelationFilter {
  is: WorkWhereInput
  isNot: WorkWhereInput
}

input WorkScalarWhereInput {
  AND: [WorkScalarWhereInput!]
  NOT: [WorkScalarWhereInput!]
  OR: [WorkScalarWhereInput!]
  averageRating: FloatFilter
  categories: StringListFilter
  description: StringFilter
  id: StringFilter
  mainEditionId: IntFilter
  ratingsCount: IntFilter
  title: StringFilter
}

type WorkSumAggregate {
  averageRating: Float
  mainEditionId: Int
  ratingsCount: Int
}

input WorkUpdateManyMutationInput {
  averageRating: Float
  categories: [String!]
  description: String
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String
}

input WorkUpdateManyWithWhereWithoutAuthorsInput {
  data: WorkUpdateManyMutationInput!
  where: WorkScalarWhereInput!
}

input WorkUpdateManyWithoutAuthorsNestedInput {
  connect: [WorkWhereUniqueInput!]
  connectOrCreate: [WorkCreateOrConnectWithoutAuthorsInput!]
  create: [WorkCreateWithoutAuthorsInput!]
  delete: [WorkWhereUniqueInput!]
  deleteMany: [WorkScalarWhereInput!]
  disconnect: [WorkWhereUniqueInput!]
  set: [WorkWhereUniqueInput!]
  update: [WorkUpdateWithWhereUniqueWithoutAuthorsInput!]
  updateMany: [WorkUpdateManyWithWhereWithoutAuthorsInput!]
  upsert: [WorkUpsertWithWhereUniqueWithoutAuthorsInput!]
}

input WorkUpdateOneWithoutEditionsNestedInput {
  connect: WorkWhereUniqueInput
  connectOrCreate: WorkCreateOrConnectWithoutEditionsInput
  create: WorkCreateWithoutEditionsInput
  delete: WorkWhereInput
  disconnect: WorkWhereInput
  update: WorkUpdateToOneWithWhereWithoutEditionsInput
  upsert: WorkUpsertWithoutEditionsInput
}

input WorkUpdateToOneWithWhereWithoutEditionsInput {
  data: WorkUpdateWithoutEditionsInput!
  where: WorkWhereInput
}

input WorkUpdateWithWhereUniqueWithoutAuthorsInput {
  data: WorkUpdateWithoutAuthorsInput!
  where: WorkWhereUniqueInput!
}

input WorkUpdateWithoutAuthorsInput {
  averageRating: Float
  categories: [String!]
  description: String
  editions: BookUpdateManyWithoutWorkNestedInput
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String
}

input WorkUpdateWithoutEditionsInput {
  authors: AuthorUpdateManyWithoutWorksNestedInput
  averageRating: Float
  categories: [String!]
  description: String
  id: String
  mainEditionId: Int
  ratingsCount: Int
  title: String
}

input WorkUpsertWithWhereUniqueWithoutAuthorsInput {
  create: WorkCreateWithoutAuthorsInput!
  update: WorkUpdateWithoutAuthorsInput!
  where: WorkWhereUniqueInput!
}

input WorkUpsertWithoutEditionsInput {
  create: WorkCreateWithoutEditionsInput!
  update: WorkUpdateWithoutEditionsInput!
  where: WorkWhereInput
}

input WorkWhereInput {
  AND: [WorkWhereInput!]
  NOT: [WorkWhereInput!]
  OR: [WorkWhereInput!]
  authors: AuthorListRelationFilter
  averageRating: FloatFilter
  categories: StringListFilter
  description: StringFilter
  editions: BookListRelationFilter
  id: StringFilter
  mainEditionId: IntFilter
  ratingsCount: IntFilter
  title: StringFilter
}

input WorkWhereUniqueInput {
  AND: [WorkWhereInput!]
  NOT: [WorkWhereInput!]
  OR: [WorkWhereInput!]
  authors: AuthorListRelationFilter
  averageRating: FloatFilter
  categories: StringListFilter
  description: StringFilter
  editions: BookListRelationFilter
  id: String
  mainEditionId: IntFilter
  ratingsCount: IntFilter
  title: StringFilter
}