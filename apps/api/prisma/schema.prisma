generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "linux-arm64-openssl-1.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator nestgraphql {
    provider                = "node node_modules/prisma-nestjs-graphql"
    output                  = "../libs/generated-db-types"
    purgeOutput             = false
    combineScalarFilters    = true
    emitSingle              = true
    noAtomicOperations      = true
    // field validator
    fields_Validator_input  = true
    fields_Validator_output = true
    fields_Validator_model  = true
    fields_Validator_from   = "class-validator"
    // Args where|data nested validator
    decorate_1_type         = "*Args"
    decorate_1_field        = "@(data|where)"
    decorate_1_name         = ValidateNested
    decorate_1_from         = "class-validator"
    decorate_1_arguments    = "[]"
}

model User {
    id String @id @default(uuid())

    /// @Validator.IsEmail()
    email String @unique

    /// @Validator.IsString()
    /// @Validator.MaxLength(100)
    /// @Validator.MinLength(3)
    username String? @unique

    /// @Validator.IsString()
    /// @HideField()
    hashedPassword String?

    /// @Validator.IsString()
    /// @HideField()
    hashedRefreshToken String?
    createdAt          DateTime   @default(now())
    updatedAt          DateTime   @updatedAt
    //  One to Many: one user has many user books
    userBooks          UserBook[]
    //  One to Many: one user has many shelves
    shelves            Shelf[]
}

// Table stores all books
model Book {
    /// @Validator.IsString()
    id          String     @unique
    /// @Validator.IsString()
    title       String
    /// @Validator.IsString()
    author      String?
    /// @Validator.IsString()
    pubDate     String?
    /// @Validator.IsString()
    publisher   String?
    /// @Validator.IsString()
    coverImage  String?
    /// @Validator.IsString()
    description String?
    /// @Validator.IsInt()
    pageNum     Int?
    /// @Validator.IsString()
    categories  String?
    // One to Many: multiple users can own the same book
    userBook    UserBook[]
}

// Table stores all user books
model UserBook {
    /// @Validator.IsString()
    id           String      @id @default(uuid())
    /// @Validator.IsString()
    userId       String
    /// @Validator.IsString()
    bookId       String
    /// @Validator.IsString()
    status       String //WANT TO READ, READ, READING, DID NOT FINISH, UP NEXT
    /// @Validator.Min(1)
    /// @Validator.Max(5)
    /// @Validator.IsInt()
    rating       Int?
    // Many to One: many user books belong to one user when user is deleted all user books are deleted as well
    user         User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
    // Many to One: many user books belong to one book when book
    book         Book?       @relation(fields: [bookId], references: [id], onDelete: Cascade)
    // One to One: one user book has one shelf entry
    ShelfEntry   ShelfEntry?
    dateStarted  String?
    dateFinished String?
    // createdAt    DateTime    @default(now())
    // updatedAt    DateTime    @updatedAt

    /// @Validator.IsString()
    @@unique(fields: [userId, bookId], name: "uniqueUserBook")
}

model Shelf {
    id               String       @id @default(uuid())
    shelfName        String
    shelfDescription String?
    userId           String
    dateTime         String?
    // One to Many: one shelf has many entries
    shelfEntries     ShelfEntry[]
    // Many to One: many shelves belong to one user when user is deleted all shelves are deleted as well
    user             User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ShelfEntry {
    id         String   @id @default(uuid())
    shelfId    String
    userBookId String   @unique
    dateTime   String?
    // Many to One: many entries belong to one shelf, when shelf is deleted all shelf entries are deleted as well
    shelf      Shelf    @relation(fields: [shelfId], references: [id], onDelete: Cascade)
    // One to One: one entry has one user book, when user book is deleted from the users library it is removed from its shelf
    userBook   UserBook @relation(fields: [userBookId], references: [id], onDelete: Cascade)
}
